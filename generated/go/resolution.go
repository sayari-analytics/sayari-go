// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/sayari-analytics/sayari-go/generated/go/core"
)

type Resolution struct {
	// A limit on the number of objects to be returned with a range between 1 and 10 inclusive. Defaults to 10.
	Limit *int `json:"-" url:"limit,omitempty"`
	// Number of results to skip before returning response. Defaults to 0.
	Offset *int `json:"-" url:"offset,omitempty"`
	// Entity name
	Name []*string `json:"-" url:"name,omitempty"`
	// Entity address. For optimal matching results, it's recommended to concatenate the full address string (street, city, state, postal code).
	Address []*string `json:"-" url:"address,omitempty"`
	// Entity city that contains the provided city name.
	City []*string `json:"-" url:"city,omitempty"`
	// Entity state that contains the provided state name.
	State []*string `json:"-" url:"state,omitempty"`
	// Entity country - must be ISO (3166) Trigram i.e., `USA`. See complete list [here](/sayari-library/ontology/enumerated-types#country)
	Country []*Country `json:"-" url:"country,omitempty"`
	// Entity identifier. Can be from either the [Identifier Type](/sayari-library/ontology/enumerated-types#identifier-type) or [Weak Identifier Type](/sayari-library/ontology/enumerated-types#weak-identifier-type) enums.
	Identifier []*BothIdentifierTypes `json:"-" url:"identifier,omitempty"`
	// Entity date of birth
	DateOfBirth []*string `json:"-" url:"date_of_birth,omitempty"`
	// Entity contact
	Contact []*string `json:"-" url:"contact,omitempty"`
	// [Entity type](/sayari-library/ontology/entities). If multiple values are passed for any field, the endpoint will match entities with ANY of the values.
	Type []*Entities `json:"-" url:"type,omitempty"`
	// Specifies the search algorithm to use. `corporate` (default) is optimized for accurate entity attribute matching, ideal for business verification. `suppliers` is tailored for matching entities with trade data, suitable for supply chain use cases. `search` mimics /search/entity behavior, best for name-only matches.
	Profile *ProfileEnum `json:"-" url:"profile,omitempty"`
	// Adding this param enables an alternative matching logic. It will set a minimum percentage of tokens needed to match with user input to be considered a "hit". Accepts integers from 0 to 100 inclusive.
	NameMinPercentage *int `json:"-" url:"name_min_percentage,omitempty"`
	// Adding this param enables an alternative matching logic. It sets the minimum number of matching tokens the resolved hits need to have in common with the user input to be considered a "hit". Accepts non-negative integers.
	NameMinTokens *int `json:"-" url:"name_min_tokens,omitempty"`
	// Specifies the minimum score required to pass, which controls the strictness of the matching threshold. The default value is 77, and tuned for general use-case accuracy. Increase the value for stricter matching, reduce to loosen.
	MinimumScoreThreshold *int `json:"-" url:"minimum_score_threshold,omitempty"`
	// Enables a name search fallback when either the corporate or supplier profiles fails to find a match. When invoked, the fallback will make a call similar to /search/entity on name only. By default set to false.
	SearchFallback *bool `json:"-" url:"search_fallback,omitempty"`
	// Specifies the window of similar results returned in the match group. Increase for fewer multiple matches, decrease to open the aperture and allow for more matches. Default is .8
	CutoffThreshold *int `json:"-" url:"cutoff_threshold,omitempty"`
	// Specifies the maximum number of entity candidates considered during search. Default is 50. Higher values increase match pool size but also increase latency.
	CandidatePoolSize *int `json:"-" url:"candidate_pool_size,omitempty"`
	// Bypasses the post-processing setps and re-ranking. Useful for debugging. By default set to false, set to true to enable.
	SkipPostProcess *bool `json:"-" url:"skip_post_process,omitempty"`
}

type ResolutionPost struct {
	// A limit on the number of objects to be returned with a range between 1 and 10 inclusive. Defaults to 10.
	Limit *int `json:"-" url:"limit,omitempty"`
	// Number of results to skip before returning response. Defaults to 0.
	Offset *int            `json:"-" url:"offset,omitempty"`
	Body   *ResolutionBody `json:"-" url:"-"`
}

func (r *ResolutionPost) UnmarshalJSON(data []byte) error {
	body := new(ResolutionBody)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	r.Body = body
	return nil
}

func (r *ResolutionPost) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.Body)
}

type ResolutionPersisted struct {
	// A limit on the number of objects to be returned with a range between 1 and 10 inclusive. Defaults to 10.
	Limit *int `json:"-" url:"limit,omitempty"`
	// Number of results to skip before returning response. Defaults to 0.
	Offset *int            `json:"-" url:"offset,omitempty"`
	Body   *ResolutionBody `json:"-" url:"-"`
}

func (r *ResolutionPersisted) UnmarshalJSON(data []byte) error {
	body := new(ResolutionBody)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	r.Body = body
	return nil
}

func (r *ResolutionPersisted) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.Body)
}

type MatchExplanation struct {
	Matched              *string            `json:"matched,omitempty" url:"matched,omitempty"`
	Uploaded             *string            `json:"uploaded,omitempty" url:"uploaded,omitempty"`
	NameCustomTfIdfScore *float64           `json:"name_custom_tf_idf_score,omitempty" url:"name_custom_tf_idf_score,omitempty"`
	HighQualityMatchName *bool              `json:"high_quality_match_name,omitempty" url:"high_quality_match_name,omitempty"`
	Scores               map[string]float64 `json:"scores,omitempty" url:"scores,omitempty"`
	NCommonTermMatches   *int               `json:"n_common_term_matches,omitempty" url:"n_common_term_matches,omitempty"`
	NUncommonTermMatches *int               `json:"n_uncommon_term_matches,omitempty" url:"n_uncommon_term_matches,omitempty"`
	MatchQuality         *MatchQuality      `json:"match_quality,omitempty" url:"match_quality,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MatchExplanation) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MatchExplanation) UnmarshalJSON(data []byte) error {
	type unmarshaler MatchExplanation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MatchExplanation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MatchExplanation) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Represents the quality of the field match
type MatchQuality string

const (
	MatchQualityHigh   MatchQuality = "high"
	MatchQualityMedium MatchQuality = "medium"
	MatchQualityLow    MatchQuality = "low"
)

func NewMatchQualityFromString(s string) (MatchQuality, error) {
	switch s {
	case "high":
		return MatchQualityHigh, nil
	case "medium":
		return MatchQualityMedium, nil
	case "low":
		return MatchQualityLow, nil
	}
	var t MatchQuality
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MatchQuality) Ptr() *MatchQuality {
	return &m
}

type MatchStrength struct {
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MatchStrength) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MatchStrength) UnmarshalJSON(data []byte) error {
	type unmarshaler MatchStrength
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MatchStrength(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MatchStrength) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ProfileEnum string

const (
	ProfileEnumCorporate ProfileEnum = "corporate"
	ProfileEnumSuppliers ProfileEnum = "suppliers"
	ProfileEnumSearch    ProfileEnum = "search"
	ProfileEnumScreen    ProfileEnum = "screen"
)

func NewProfileEnumFromString(s string) (ProfileEnum, error) {
	switch s {
	case "corporate":
		return ProfileEnumCorporate, nil
	case "suppliers":
		return ProfileEnumSuppliers, nil
	case "search":
		return ProfileEnumSearch, nil
	case "screen":
		return ProfileEnumScreen, nil
	}
	var t ProfileEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProfileEnum) Ptr() *ProfileEnum {
	return &p
}

type ResolutionBody struct {
	// Entity name
	Name []string `json:"name,omitempty" url:"name,omitempty"`
	// Entity identifier. Can be from either the [Identifier Type](/sayari-library/ontology/enumerated-types#identifier-type) or [Weak Identifier Type](/sayari-library/ontology/enumerated-types#weak-identifier-type) enums.
	Identifier *BothIdentifierTypes `json:"identifier,omitempty" url:"identifier,omitempty"`
	// Entity address
	Address []string `json:"address,omitempty" url:"address,omitempty"`
	// Entity city that contains the provided city name.
	City *string `json:"city,omitempty" url:"city,omitempty"`
	// Entity state that contains the provided state name.
	State *string `json:"state,omitempty" url:"state,omitempty"`
	// Entity country - must be ISO (3166) Trigram i.e., `USA`. See complete list [here](/sayari-library/ontology/enumerated-types#country)
	Country []Country `json:"country,omitempty" url:"country,omitempty"`
	// Entity date of birth
	DateOfBirth []string `json:"date_of_birth,omitempty" url:"date_of_birth,omitempty"`
	// Entity contact
	Contact []string `json:"contact,omitempty" url:"contact,omitempty"`
	// [Entity type](/sayari-library/ontology/entities). If multiple values are passed for any field, the endpoint will match entities with ANY of the values.
	Type []Entities `json:"type,omitempty" url:"type,omitempty"`
	// Specifies the search algorithm to use. `corporate` (default) is optimized for accurate entity attribute matching, ideal for business verification. `suppliers` is tailored for matching entities with trade data, suitable for supply chain use cases. `search` mimics /search/entity behavior, best for name-only matches.
	Profile *ProfileEnum `json:"profile,omitempty" url:"profile,omitempty"`
	// Adding this param enables an alternative matching logic. It will set a minimum percentage of tokens needed to match with user input to be considered a "hit". Accepts integers from 0 to 100 inclusive.
	NameMinPercentage *int `json:"name_min_percentage,omitempty" url:"name_min_percentage,omitempty"`
	// Adding this param enables an alternative matching logic. It sets the minimum number of matching tokens the resolved hits need to have in common with the user input to be considered a "hit". Accepts non-negative integers.
	NameMinTokens *int `json:"name_min_tokens,omitempty" url:"name_min_tokens,omitempty"`
	// An array of tag labels to associate with each resolved entity
	Tags []string `json:"tags,omitempty" url:"tags,omitempty"`
	// Specifies the minimum score required to pass, which controls the strictness of the matching threshold. The default value is 77, and tuned for general use-case accuracy. Increase the value for stricter matching, reduce to loosen.
	MinimumScoreThreshold *int `json:"minimum_score_threshold,omitempty" url:"minimum_score_threshold,omitempty"`
	// Enables a name search fallback when either the corporate or supplier profiles fails to find a match. When invoked, the fallback will make a call similar to /search/entity on name only. By default set to false.
	SearchFallback *bool `json:"search_fallback,omitempty" url:"search_fallback,omitempty"`
	// Specifies the window of similar results returned in the match group. Increase for fewer multiple matches, decrease to open the aperture and allow for more matches. Default is .8
	CutoffThreshold *int `json:"cutoff_threshold,omitempty" url:"cutoff_threshold,omitempty"`
	// Specifies the maximum number of entity candidates considered during search. Default is 50. Higher values increase match pool size but also increase latency.
	CandidatePoolSize *int `json:"candidate_pool_size,omitempty" url:"candidate_pool_size,omitempty"`
	// Bypasses the post-processing setps and re-ranking. Useful for debugging. By default set to false, set to true to enable.
	SkipPostProcess *bool `json:"skip_post_process,omitempty" url:"skip_post_process,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ResolutionBody) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResolutionBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ResolutionBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResolutionBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResolutionBody) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolutionPersistedResponse struct {
	Fields *ResolutionPersistedResponseFields `json:"fields,omitempty" url:"fields,omitempty"`
	Data   []*ResolutionPersistedResult       `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ResolutionPersistedResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResolutionPersistedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ResolutionPersistedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResolutionPersistedResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResolutionPersistedResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolutionPersistedResponseFields struct {
	Name       []string `json:"name,omitempty" url:"name,omitempty"`
	Identifier []string `json:"identifier,omitempty" url:"identifier,omitempty"`
	Profile    *string  `json:"profile,omitempty" url:"profile,omitempty"`
	// Entity country - must be ISO (3166) Trigram i.e., USA. See complete list [here](/sayari-library/ontology/enumerated-types#country)
	Country []Country `json:"country,omitempty" url:"country,omitempty"`
	// List of physical addresses associated with the entity.
	Address     []string `json:"address,omitempty" url:"address,omitempty"`
	DateOfBirth []string `json:"date_of_birth,omitempty" url:"date_of_birth,omitempty"`
	Contact     []string `json:"contact,omitempty" url:"contact,omitempty"`
	// [Entity type](/sayari-library/ontology/entities)
	Type []Entities `json:"type,omitempty" url:"type,omitempty"`
	// <Warning>This property is in beta and is subject to change. It is provided for early access and testing purposes only.</Warning> custom user key/value pairs (key must be prefixed with "custom_" and value must be "string" type)
	CustomFieldName  *string `json:"custom_{field name},omitempty" url:"custom_{field name},omitempty"`
	CustomName       *string `json:"custom_name,omitempty" url:"custom_name,omitempty"`
	CustomIdentifier *string `json:"custom_identifier,omitempty" url:"custom_identifier,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ResolutionPersistedResponseFields) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResolutionPersistedResponseFields) UnmarshalJSON(data []byte) error {
	type unmarshaler ResolutionPersistedResponseFields
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResolutionPersistedResponseFields(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResolutionPersistedResponseFields) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolutionPersistedResult struct {
	Profile             string                         `json:"profile" url:"profile"`
	Score               float64                        `json:"score" url:"score"`
	EntityId            string                         `json:"entity_id" url:"entity_id"`
	Label               string                         `json:"label" url:"label"`
	Type                Entities                       `json:"type" url:"type"`
	Identifiers         []*Identifier                  `json:"identifiers,omitempty" url:"identifiers,omitempty"`
	PsaId               *float64                       `json:"psa_id,omitempty" url:"psa_id,omitempty"`
	Addresses           []string                       `json:"addresses,omitempty" url:"addresses,omitempty"`
	Countries           []Country                      `json:"countries,omitempty" url:"countries,omitempty"`
	Sources             []string                       `json:"sources,omitempty" url:"sources,omitempty"`
	TypedMatchedQueries []string                       `json:"typed_matched_queries,omitempty" url:"typed_matched_queries,omitempty"`
	MatchedQueries      []string                       `json:"matched_queries,omitempty" url:"matched_queries,omitempty"`
	Highlight           map[string][]string            `json:"highlight,omitempty" url:"highlight,omitempty"`
	Explanation         map[string][]*MatchExplanation `json:"explanation,omitempty" url:"explanation,omitempty"`
	MatchStrength       *MatchStrength                 `json:"match_strength,omitempty" url:"match_strength,omitempty"`
	SavedEntityId       string                         `json:"saved_entity_id" url:"saved_entity_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ResolutionPersistedResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResolutionPersistedResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResolutionPersistedResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResolutionPersistedResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResolutionPersistedResult) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolutionResponse struct {
	Fields *ResolutionResponseFields `json:"fields,omitempty" url:"fields,omitempty"`
	Data   []*ResolutionResult       `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ResolutionResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResolutionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ResolutionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResolutionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResolutionResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolutionResponseFields struct {
	Name       []string `json:"name,omitempty" url:"name,omitempty"`
	Identifier []string `json:"identifier,omitempty" url:"identifier,omitempty"`
	Profile    *string  `json:"profile,omitempty" url:"profile,omitempty"`
	// Entity country - must be ISO (3166) Trigram i.e., USA. See complete list [here](/sayari-library/ontology/enumerated-types#country)
	Country []Country `json:"country,omitempty" url:"country,omitempty"`
	// List of physical addresses associated with the entity.
	Address     []string `json:"address,omitempty" url:"address,omitempty"`
	DateOfBirth []string `json:"date_of_birth,omitempty" url:"date_of_birth,omitempty"`
	Contact     []string `json:"contact,omitempty" url:"contact,omitempty"`
	// [Entity type](/sayari-library/ontology/entities)
	Type []Entities `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ResolutionResponseFields) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResolutionResponseFields) UnmarshalJSON(data []byte) error {
	type unmarshaler ResolutionResponseFields
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResolutionResponseFields(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResolutionResponseFields) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolutionResult struct {
	Profile             string                         `json:"profile" url:"profile"`
	Score               float64                        `json:"score" url:"score"`
	EntityId            string                         `json:"entity_id" url:"entity_id"`
	Label               string                         `json:"label" url:"label"`
	Type                Entities                       `json:"type" url:"type"`
	Identifiers         []*Identifier                  `json:"identifiers,omitempty" url:"identifiers,omitempty"`
	PsaId               *float64                       `json:"psa_id,omitempty" url:"psa_id,omitempty"`
	Addresses           []string                       `json:"addresses,omitempty" url:"addresses,omitempty"`
	Countries           []Country                      `json:"countries,omitempty" url:"countries,omitempty"`
	Sources             []string                       `json:"sources,omitempty" url:"sources,omitempty"`
	TypedMatchedQueries []string                       `json:"typed_matched_queries,omitempty" url:"typed_matched_queries,omitempty"`
	MatchedQueries      []string                       `json:"matched_queries,omitempty" url:"matched_queries,omitempty"`
	Highlight           map[string][]string            `json:"highlight,omitempty" url:"highlight,omitempty"`
	Explanation         map[string][]*MatchExplanation `json:"explanation,omitempty" url:"explanation,omitempty"`
	MatchStrength       *MatchStrength                 `json:"match_strength,omitempty" url:"match_strength,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ResolutionResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResolutionResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResolutionResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResolutionResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResolutionResult) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolutionUploadBody struct {
	Filename string            `json:"filename" url:"filename"`
	Data     []*ResolutionBody `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ResolutionUploadBody) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResolutionUploadBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ResolutionUploadBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResolutionUploadBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResolutionUploadBody) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolutionUploadResponse struct {
	File     string `json:"file" url:"file"`
	Uploaded string `json:"uploaded" url:"uploaded"`
	Count    int    `json:"count" url:"count"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ResolutionUploadResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResolutionUploadResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ResolutionUploadResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResolutionUploadResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResolutionUploadResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}
