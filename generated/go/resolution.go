// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/sayari-analytics/sayari-go/generated/go/core"
)

type Resolution struct {
	// A limit on the number of objects to be returned with a range between 1 and 10. Defaults to 10.
	Limit *int `json:"-" url:"limit,omitempty"`
	// Number of results to skip before returning response. Defaults to 0.
	Offset *int `json:"-" url:"offset,omitempty"`
	// Entity name
	Name []*string `json:"-" url:"name,omitempty"`
	// Entity identifier. Can be from either the [Identifier Type](/sayari-library/ontology/enumerated-types#identifier-type) or [Weak Identifier Type](/sayari-library/ontology/enumerated-types#weak-identifier-type) enums.
	Identifier []*BothIdentifierTypes `json:"-" url:"identifier,omitempty"`
	// Entity country - must be ISO (3166) Trigram i.e., `USA`. See complete list [here](/sayari-library/ontology/enumerated-types#country)
	Country []*Country `json:"-" url:"country,omitempty"`
	// Entity address
	Address []*string `json:"-" url:"address,omitempty"`
	// Entity date of birth
	DateOfBirth []*string `json:"-" url:"date_of_birth,omitempty"`
	// Entity contact
	Contact []*string `json:"-" url:"contact,omitempty"`
	// [Entity type](/sayari-library/ontology/entities). If multiple values are passed for any field, the endpoint will match entities with ANY of the values.
	Type []*Entities `json:"-" url:"type,omitempty"`
}

type ResolutionPost struct {
	// A limit on the number of objects to be returned with a range between 1 and 10. Defaults to 10.
	Limit *int `json:"-" url:"limit,omitempty"`
	// Number of results to skip before returning response. Defaults to 0.
	Offset *int `json:"-" url:"offset,omitempty"`
	// Entity name
	Name []string `json:"name,omitempty" url:"name,omitempty"`
	// Entity identifier. Can be from either the [Identifier Type](/sayari-library/ontology/enumerated-types#identifier-type) or [Weak Identifier Type](/sayari-library/ontology/enumerated-types#weak-identifier-type) enums.
	Identifier []*BothIdentifierTypes `json:"identifier,omitempty" url:"identifier,omitempty"`
	// Entity country - must be ISO (3166) Trigram i.e., `USA`. See complete list [here](/sayari-library/ontology/enumerated-types#country)
	Country []Country `json:"country,omitempty" url:"country,omitempty"`
	// Entity address
	Address []string `json:"address,omitempty" url:"address,omitempty"`
	// Entity date of birth
	DateOfBirth []string `json:"date_of_birth,omitempty" url:"date_of_birth,omitempty"`
	// Entity contact
	Contact []string `json:"contact,omitempty" url:"contact,omitempty"`
	// [Entity type](/sayari-library/ontology/entities). If multiple values are passed for any field, the endpoint will match entities with ANY of the values.
	Type []Entities `json:"type,omitempty" url:"type,omitempty"`
}

type BothIdentifierTypes struct {
	IdentifierType     IdentifierType
	WeakIdentifierType WeakIdentifierType
}

func NewBothIdentifierTypesFromIdentifierType(value IdentifierType) *BothIdentifierTypes {
	return &BothIdentifierTypes{IdentifierType: value}
}

func NewBothIdentifierTypesFromWeakIdentifierType(value WeakIdentifierType) *BothIdentifierTypes {
	return &BothIdentifierTypes{WeakIdentifierType: value}
}

func (b *BothIdentifierTypes) UnmarshalJSON(data []byte) error {
	var valueIdentifierType IdentifierType
	if err := json.Unmarshal(data, &valueIdentifierType); err == nil {
		b.IdentifierType = valueIdentifierType
		return nil
	}
	var valueWeakIdentifierType WeakIdentifierType
	if err := json.Unmarshal(data, &valueWeakIdentifierType); err == nil {
		b.WeakIdentifierType = valueWeakIdentifierType
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BothIdentifierTypes) MarshalJSON() ([]byte, error) {
	if b.IdentifierType != "" {
		return json.Marshal(b.IdentifierType)
	}
	if b.WeakIdentifierType != "" {
		return json.Marshal(b.WeakIdentifierType)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BothIdentifierTypesVisitor interface {
	VisitIdentifierType(IdentifierType) error
	VisitWeakIdentifierType(WeakIdentifierType) error
}

func (b *BothIdentifierTypes) Accept(visitor BothIdentifierTypesVisitor) error {
	if b.IdentifierType != "" {
		return visitor.VisitIdentifierType(b.IdentifierType)
	}
	if b.WeakIdentifierType != "" {
		return visitor.VisitWeakIdentifierType(b.WeakIdentifierType)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", b)
}

// OK
type ResolutionResponse struct {
	Fields *ResolutionResponseFields `json:"fields,omitempty" url:"fields,omitempty"`
	Data   []*ResolutionResult       `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (r *ResolutionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ResolutionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResolutionResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResolutionResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}
