// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/sayari-analytics/sayari-go/generated/go/internal"
)

type GetRecord struct {
	// A limit on the number of references to be returned. Defaults to 100.
	ReferencesLimit *int `json:"-" url:"references.limit,omitempty"`
	// Number of references to skip before returning response. Defaults to 0.
	ReferencesOffset *int `json:"-" url:"references.offset,omitempty"`
}

// OK
type GetRecordResponse struct {
	// The unique identifier for a record in the database
	Id    string `json:"id" url:"id"`
	Label string `json:"label" url:"label"`
	// The unique identifier for a source in the database
	Source string `json:"source" url:"source"`
	// The date the record was published
	PublicationDate *string `json:"publication_date,omitempty" url:"publication_date,omitempty"`
	// The date Sayari acquired this record
	AcquisitionDate string `json:"acquisition_date" url:"acquisition_date"`
	// Number of times this record is referenced
	ReferencesCount int `json:"references_count" url:"references_count"`
	// The url to download the record from Sayari
	RecordUrl string `json:"record_url" url:"record_url"`
	// The url to access to original source
	SourceUrl    *string             `json:"source_url,omitempty" url:"source_url,omitempty"`
	DocumentUrls []string            `json:"document_urls,omitempty" url:"document_urls,omitempty"`
	Matches      map[string][]string `json:"matches,omitempty" url:"matches,omitempty"`
	Country      *Country            `json:"country,omitempty" url:"country,omitempty"`
	Page         *float64            `json:"page,omitempty" url:"page,omitempty"`
	PageCount    *float64            `json:"page_count,omitempty" url:"page_count,omitempty"`
	References   *RecordReferences   `json:"references,omitempty" url:"references,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetRecordResponse) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GetRecordResponse) GetLabel() string {
	if g == nil {
		return ""
	}
	return g.Label
}

func (g *GetRecordResponse) GetSource() string {
	if g == nil {
		return ""
	}
	return g.Source
}

func (g *GetRecordResponse) GetPublicationDate() *string {
	if g == nil {
		return nil
	}
	return g.PublicationDate
}

func (g *GetRecordResponse) GetAcquisitionDate() string {
	if g == nil {
		return ""
	}
	return g.AcquisitionDate
}

func (g *GetRecordResponse) GetReferencesCount() int {
	if g == nil {
		return 0
	}
	return g.ReferencesCount
}

func (g *GetRecordResponse) GetRecordUrl() string {
	if g == nil {
		return ""
	}
	return g.RecordUrl
}

func (g *GetRecordResponse) GetSourceUrl() *string {
	if g == nil {
		return nil
	}
	return g.SourceUrl
}

func (g *GetRecordResponse) GetDocumentUrls() []string {
	if g == nil {
		return nil
	}
	return g.DocumentUrls
}

func (g *GetRecordResponse) GetMatches() map[string][]string {
	if g == nil {
		return nil
	}
	return g.Matches
}

func (g *GetRecordResponse) GetCountry() *Country {
	if g == nil {
		return nil
	}
	return g.Country
}

func (g *GetRecordResponse) GetPage() *float64 {
	if g == nil {
		return nil
	}
	return g.Page
}

func (g *GetRecordResponse) GetPageCount() *float64 {
	if g == nil {
		return nil
	}
	return g.PageCount
}

func (g *GetRecordResponse) GetReferences() *RecordReferences {
	if g == nil {
		return nil
	}
	return g.References
}

func (g *GetRecordResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetRecordResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetRecordResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetRecordResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetRecordResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type RecordReferences struct {
	Limit  int             `json:"limit" url:"limit"`
	Size   *QualifiedCount `json:"size,omitempty" url:"size,omitempty"`
	Next   bool            `json:"next" url:"next"`
	Offset int             `json:"offset" url:"offset"`
	Data   interface{}     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RecordReferences) GetLimit() int {
	if r == nil {
		return 0
	}
	return r.Limit
}

func (r *RecordReferences) GetSize() *QualifiedCount {
	if r == nil {
		return nil
	}
	return r.Size
}

func (r *RecordReferences) GetNext() bool {
	if r == nil {
		return false
	}
	return r.Next
}

func (r *RecordReferences) GetOffset() int {
	if r == nil {
		return 0
	}
	return r.Offset
}

func (r *RecordReferences) GetData() interface{} {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *RecordReferences) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordReferences) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordReferences
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordReferences(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordReferences) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}
