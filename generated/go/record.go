// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/sayari-analytics/sayari-go/generated/go/core"
)

type GetRecord struct {
	// A limit on the number of references to be returned. Defaults to 100.
	ReferencesLimit *int `json:"-" url:"references.limit,omitempty"`
	// Number of references to skip before returning response. Defaults to 0.
	ReferencesOffset *int `json:"-" url:"references.offset,omitempty"`
}

// OK
type GetRecordResponse struct {
	// The unique identifier for a record in the database
	Id    string `json:"id" url:"id"`
	Label string `json:"label" url:"label"`
	// The unique identifier for a source in the database
	Source string `json:"source" url:"source"`
	// The date the record was published
	PublicationDate *string `json:"publication_date,omitempty" url:"publication_date,omitempty"`
	// The date Sayari acquired this record
	AcquisitionDate string `json:"acquisition_date" url:"acquisition_date"`
	// Number of times this record is referenced
	ReferencesCount int `json:"references_count" url:"references_count"`
	// The url to download the record from Sayari
	RecordUrl string `json:"record_url" url:"record_url"`
	// The url to access to original source
	SourceUrl    *string             `json:"source_url,omitempty" url:"source_url,omitempty"`
	DocumentUrls []string            `json:"document_urls,omitempty" url:"document_urls,omitempty"`
	Matches      map[string][]string `json:"matches,omitempty" url:"matches,omitempty"`
	Country      *Country            `json:"country,omitempty" url:"country,omitempty"`
	Page         *float64            `json:"page,omitempty" url:"page,omitempty"`
	PageCount    *float64            `json:"page_count,omitempty" url:"page_count,omitempty"`
	References   *RecordReferences   `json:"references,omitempty" url:"references,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetRecordResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetRecordResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetRecordResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetRecordResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetRecordResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type RecordReferences struct {
	Limit  int             `json:"limit" url:"limit"`
	Size   *QualifiedCount `json:"size,omitempty" url:"size,omitempty"`
	Next   bool            `json:"next" url:"next"`
	Offset int             `json:"offset" url:"offset"`
	Data   interface{}     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RecordReferences) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordReferences) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordReferences
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordReferences(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordReferences) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}
