// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/sayari-analytics/sayari-go/generated/go/internal"
)

type GetProjectEntities struct {
	// The response format. Defaults to application/json.
	Accept GetProjectEntitiesAcceptHeader `json:"-" url:"-"`
	// The pagination token for the next page of entities.
	Next *string `json:"-" url:"next,omitempty"`
	// The pagination token for the previous page of entities.
	Prev *string `json:"-" url:"prev,omitempty"`
	// Limit total entities returned. Defaults to 1,000. Max 10,000.
	Limit *int `json:"-" url:"limit,omitempty"`
	// Only return entities of the specified [entity type(s)](/sayari-library/ontology/entities). Defaults to all types.
	EntityTypes []*Entities `json:"-" url:"entity_types,omitempty"`
	// Whether to include geo facets in the response. Defaults to false.
	GeoFacets *bool `json:"-" url:"geo_facets,omitempty"`
	// Only return entities with the specified HS code(s).
	HsCodes []*string `json:"-" url:"hs_codes,omitempty"`
	// Only return entities that received the specified HS code(s).
	ReceivedHsCodes []*string `json:"-" url:"received_hs_codes,omitempty"`
	// Only return entities that shipped the specified HS code(s).
	ShippedHsCodes []*string `json:"-" url:"shipped_hs_codes,omitempty"`
	// Only return entities that have shipped or received the specified HS code(s).
	CombinedHsCodes []*string `json:"-" url:"combined_hs_codes,omitempty"`
	// The language code to translate the entity labels to. Defaults to the user's preferred language.
	Translation *string    `json:"-" url:"translation,omitempty"`
	Sort        *SortField `json:"-" url:"sort,omitempty"`
	// Filter for entities in a project. The format is `field=value`, where the equal sign is encoded as `%3D`. Supported fields are as follows
	Filters []*ProjectEntitiesFilter `json:"-" url:"filters,omitempty"`
	// Aggregations that should be returned for entities in the project.
	Aggregations []*ProjectEntitiesAggsDefinition `json:"-" url:"aggregations,omitempty"`
}

type GetProjects struct {
	// The pagination token for the next page of projects.
	Next *string `json:"-" url:"next,omitempty"`
	// The pagination token for the previous page of projects.
	Prev *string `json:"-" url:"prev,omitempty"`
	// Limit total values returned for projects. Defaults to 100. Max 100.
	Limit *int `json:"-" url:"limit,omitempty"`
	// Toggle between projects that have been archived (true) or not (false). Defaults to false.
	Archived *bool `json:"-" url:"archived,omitempty"`
}

// Aggregation buckets for entities in a project.
type BucketAgg struct {
	Key        string       `json:"key" url:"key"`
	DocCount   int          `json:"doc_count" url:"doc_count"`
	Label      *string      `json:"label,omitempty" url:"label,omitempty"`
	Comment    *string      `json:"comment,omitempty" url:"comment,omitempty"`
	HsCodeSums *IntKeyValue `json:"hs_code_sums,omitempty" url:"hs_code_sums,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BucketAgg) GetKey() string {
	if b == nil {
		return ""
	}
	return b.Key
}

func (b *BucketAgg) GetDocCount() int {
	if b == nil {
		return 0
	}
	return b.DocCount
}

func (b *BucketAgg) GetLabel() *string {
	if b == nil {
		return nil
	}
	return b.Label
}

func (b *BucketAgg) GetComment() *string {
	if b == nil {
		return nil
	}
	return b.Comment
}

func (b *BucketAgg) GetHsCodeSums() *IntKeyValue {
	if b == nil {
		return nil
	}
	return b.HsCodeSums
}

func (b *BucketAgg) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BucketAgg) UnmarshalJSON(data []byte) error {
	type unmarshaler BucketAgg
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BucketAgg(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BucketAgg) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CreateProjectRequest struct {
	Label string `json:"label" url:"label"`
	// Specifies access levels available to users in a project within an organization. For comprehensive access, the admin role is recommended.
	Share *ProjectShareOnCreate `json:"share,omitempty" url:"share,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateProjectRequest) GetLabel() string {
	if c == nil {
		return ""
	}
	return c.Label
}

func (c *CreateProjectRequest) GetShare() *ProjectShareOnCreate {
	if c == nil {
		return nil
	}
	return c.Share
}

func (c *CreateProjectRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateProjectRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateProjectRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateProjectRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateProjectRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateProjectResponse struct {
	Data *Project `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateProjectResponse) GetData() *Project {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CreateProjectResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateProjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateProjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateProjectResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateProjectResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DeleteProjectResponse struct {
	Data *Project `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteProjectResponse) GetData() *Project {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DeleteProjectResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteProjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteProjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteProjectResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteProjectResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DocCount struct {
	DocCount int `json:"doc_count" url:"doc_count"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DocCount) GetDocCount() int {
	if d == nil {
		return 0
	}
	return d.DocCount
}

func (d *DocCount) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocCount) UnmarshalJSON(data []byte) error {
	type unmarshaler DocCount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocCount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocCount) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type GetProjectEntitiesAcceptHeader string

const (
	GetProjectEntitiesAcceptHeaderJson GetProjectEntitiesAcceptHeader = "application/json"
	GetProjectEntitiesAcceptHeaderCsv  GetProjectEntitiesAcceptHeader = "text/csv"
	GetProjectEntitiesAcceptHeaderXslx GetProjectEntitiesAcceptHeader = "application/vnd.ms-excel"
)

func NewGetProjectEntitiesAcceptHeaderFromString(s string) (GetProjectEntitiesAcceptHeader, error) {
	switch s {
	case "application/json":
		return GetProjectEntitiesAcceptHeaderJson, nil
	case "text/csv":
		return GetProjectEntitiesAcceptHeaderCsv, nil
	case "application/vnd.ms-excel":
		return GetProjectEntitiesAcceptHeaderXslx, nil
	}
	var t GetProjectEntitiesAcceptHeader
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetProjectEntitiesAcceptHeader) Ptr() *GetProjectEntitiesAcceptHeader {
	return &g
}

type GetProjectEntitiesResponse struct {
	Limit        int                  `json:"limit" url:"limit"`
	Size         *QualifiedCount      `json:"size,omitempty" url:"size,omitempty"`
	Next         *string              `json:"next,omitempty" url:"next,omitempty"`
	Prev         *string              `json:"prev,omitempty" url:"prev,omitempty"`
	Data         []*ProjectEntity     `json:"data,omitempty" url:"data,omitempty"`
	Aggregations *ProjectEntitiesAggs `json:"aggregations,omitempty" url:"aggregations,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetProjectEntitiesResponse) GetLimit() int {
	if g == nil {
		return 0
	}
	return g.Limit
}

func (g *GetProjectEntitiesResponse) GetSize() *QualifiedCount {
	if g == nil {
		return nil
	}
	return g.Size
}

func (g *GetProjectEntitiesResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GetProjectEntitiesResponse) GetPrev() *string {
	if g == nil {
		return nil
	}
	return g.Prev
}

func (g *GetProjectEntitiesResponse) GetData() []*ProjectEntity {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GetProjectEntitiesResponse) GetAggregations() *ProjectEntitiesAggs {
	if g == nil {
		return nil
	}
	return g.Aggregations
}

func (g *GetProjectEntitiesResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetProjectEntitiesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetProjectEntitiesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetProjectEntitiesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetProjectEntitiesResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetProjectsResponse struct {
	Next  *string               `json:"next,omitempty" url:"next,omitempty"`
	Prev  *string               `json:"prev,omitempty" url:"prev,omitempty"`
	First *bool                 `json:"first,omitempty" url:"first,omitempty"`
	Last  *bool                 `json:"last,omitempty" url:"last,omitempty"`
	Limit int                   `json:"limit" url:"limit"`
	Data  []*ProjectWithMembers `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetProjectsResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GetProjectsResponse) GetPrev() *string {
	if g == nil {
		return nil
	}
	return g.Prev
}

func (g *GetProjectsResponse) GetFirst() *bool {
	if g == nil {
		return nil
	}
	return g.First
}

func (g *GetProjectsResponse) GetLast() *bool {
	if g == nil {
		return nil
	}
	return g.Last
}

func (g *GetProjectsResponse) GetLimit() int {
	if g == nil {
		return 0
	}
	return g.Limit
}

func (g *GetProjectsResponse) GetData() []*ProjectWithMembers {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GetProjectsResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetProjectsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetProjectsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetProjectsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetProjectsResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type HsCodeAgg struct {
	DocCount    int             `json:"doc_count" url:"doc_count"`
	HsCodeTerms *HsCodeAggTerms `json:"hs_code_terms,omitempty" url:"hs_code_terms,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HsCodeAgg) GetDocCount() int {
	if h == nil {
		return 0
	}
	return h.DocCount
}

func (h *HsCodeAgg) GetHsCodeTerms() *HsCodeAggTerms {
	if h == nil {
		return nil
	}
	return h.HsCodeTerms
}

func (h *HsCodeAgg) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HsCodeAgg) UnmarshalJSON(data []byte) error {
	type unmarshaler HsCodeAgg
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HsCodeAgg(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HsCodeAgg) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HsCodeAggBucket struct {
	Key        string       `json:"key" url:"key"`
	DocCount   int          `json:"doc_count" url:"doc_count"`
	HsCodeSums *IntKeyValue `json:"hs_code_sums,omitempty" url:"hs_code_sums,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HsCodeAggBucket) GetKey() string {
	if h == nil {
		return ""
	}
	return h.Key
}

func (h *HsCodeAggBucket) GetDocCount() int {
	if h == nil {
		return 0
	}
	return h.DocCount
}

func (h *HsCodeAggBucket) GetHsCodeSums() *IntKeyValue {
	if h == nil {
		return nil
	}
	return h.HsCodeSums
}

func (h *HsCodeAggBucket) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HsCodeAggBucket) UnmarshalJSON(data []byte) error {
	type unmarshaler HsCodeAggBucket
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HsCodeAggBucket(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HsCodeAggBucket) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HsCodeAggTerms struct {
	DocCountErrorUpperBound int                `json:"doc_count_error_upper_bound" url:"doc_count_error_upper_bound"`
	SumOtherDocCount        int                `json:"sum_other_doc_count" url:"sum_other_doc_count"`
	Buckets                 []*HsCodeAggBucket `json:"buckets,omitempty" url:"buckets,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HsCodeAggTerms) GetDocCountErrorUpperBound() int {
	if h == nil {
		return 0
	}
	return h.DocCountErrorUpperBound
}

func (h *HsCodeAggTerms) GetSumOtherDocCount() int {
	if h == nil {
		return 0
	}
	return h.SumOtherDocCount
}

func (h *HsCodeAggTerms) GetBuckets() []*HsCodeAggBucket {
	if h == nil {
		return nil
	}
	return h.Buckets
}

func (h *HsCodeAggTerms) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HsCodeAggTerms) UnmarshalJSON(data []byte) error {
	type unmarshaler HsCodeAggTerms
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HsCodeAggTerms(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HsCodeAggTerms) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type IntKeyValue struct {
	Value int `json:"value" url:"value"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IntKeyValue) GetValue() int {
	if i == nil {
		return 0
	}
	return i.Value
}

func (i *IntKeyValue) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntKeyValue) UnmarshalJSON(data []byte) error {
	type unmarshaler IntKeyValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntKeyValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntKeyValue) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type PsaSummary struct {
	Risk      []Risk    `json:"risk,omitempty" url:"risk,omitempty"`
	Countries []Country `json:"countries,omitempty" url:"countries,omitempty"`
	Count     int       `json:"count" url:"count"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PsaSummary) GetRisk() []Risk {
	if p == nil {
		return nil
	}
	return p.Risk
}

func (p *PsaSummary) GetCountries() []Country {
	if p == nil {
		return nil
	}
	return p.Countries
}

func (p *PsaSummary) GetCount() int {
	if p == nil {
		return 0
	}
	return p.Count
}

func (p *PsaSummary) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PsaSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler PsaSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PsaSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PsaSummary) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Project struct {
	// Unique project identifier.
	Id string `json:"id" url:"id"`
	// Most recently set name for the project.
	Label string `json:"label" url:"label"`
	// Whether the project is archived. Archival is a soft delete.
	Archived bool           `json:"archived" url:"archived"`
	Created  string         `json:"created" url:"created"`
	Updated  string         `json:"updated" url:"updated"`
	Counts   *ProjectCounts `json:"counts,omitempty" url:"counts,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Project) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *Project) GetLabel() string {
	if p == nil {
		return ""
	}
	return p.Label
}

func (p *Project) GetArchived() bool {
	if p == nil {
		return false
	}
	return p.Archived
}

func (p *Project) GetCreated() string {
	if p == nil {
		return ""
	}
	return p.Created
}

func (p *Project) GetUpdated() string {
	if p == nil {
		return ""
	}
	return p.Updated
}

func (p *Project) GetCounts() *ProjectCounts {
	if p == nil {
		return nil
	}
	return p.Counts
}

func (p *Project) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Project) UnmarshalJSON(data []byte) error {
	type unmarshaler Project
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Project(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Project) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectCounts struct {
	// The number of entities in the project.
	Entity *int `json:"entity,omitempty" url:"entity,omitempty"`
	Graph  *int `json:"graph,omitempty" url:"graph,omitempty"`
	Search *int `json:"search,omitempty" url:"search,omitempty"`
	Record *int `json:"record,omitempty" url:"record,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectCounts) GetEntity() *int {
	if p == nil {
		return nil
	}
	return p.Entity
}

func (p *ProjectCounts) GetGraph() *int {
	if p == nil {
		return nil
	}
	return p.Graph
}

func (p *ProjectCounts) GetSearch() *int {
	if p == nil {
		return nil
	}
	return p.Search
}

func (p *ProjectCounts) GetRecord() *int {
	if p == nil {
		return nil
	}
	return p.Record
}

func (p *ProjectCounts) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectCounts) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectCounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectCounts(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectCounts) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Aggregation buckets for entities in a project.
type ProjectEntitiesAggs struct {
	HitCount             []*BucketAgg  `json:"hit_count,omitempty" url:"hit_count,omitempty"`
	Country              []*BucketAgg  `json:"country,omitempty" url:"country,omitempty"`
	UpstreamCountry      []*BucketAgg  `json:"upstream_country,omitempty" url:"upstream_country,omitempty"`
	UpstreamCountryTiers *TierCountAgg `json:"upstream_country_tiers,omitempty" url:"upstream_country_tiers,omitempty"`
	Risk                 []*BucketAgg  `json:"risk,omitempty" url:"risk,omitempty"`
	UpstreamRisk         []*BucketAgg  `json:"upstream_risk,omitempty" url:"upstream_risk,omitempty"`
	UpstreamRiskTiers    *TierCountAgg `json:"upstream_risk_tiers,omitempty" url:"upstream_risk_tiers,omitempty"`
	Source               []*BucketAgg  `json:"source,omitempty" url:"source,omitempty"`
	BusinessPurpose      []*BucketAgg  `json:"business_purpose,omitempty" url:"business_purpose,omitempty"`
	TagIds               []*BucketAgg  `json:"tag_ids,omitempty" url:"tag_ids,omitempty"`
	CaseStatuses         []*BucketAgg  `json:"case_statuses,omitempty" url:"case_statuses,omitempty"`
	ShipmentCounts       []*BucketAgg  `json:"shipment_counts,omitempty" url:"shipment_counts,omitempty"`
	ShippedHsCodes       *HsCodeAgg    `json:"shipped_hs_codes,omitempty" url:"shipped_hs_codes,omitempty"`
	ReceivedHsCodes      *HsCodeAgg    `json:"received_hs_codes,omitempty" url:"received_hs_codes,omitempty"`
	CombinedHsCodes      *HsCodeAgg    `json:"combined_hs_codes,omitempty" url:"combined_hs_codes,omitempty"`
	MatchResults         []*BucketAgg  `json:"match_results,omitempty" url:"match_results,omitempty"`
	CustomFields         []*BucketAgg  `json:"custom_fields,omitempty" url:"custom_fields,omitempty"`
	CustomFieldsCount    *IntKeyValue  `json:"custom_fields_count,omitempty" url:"custom_fields_count,omitempty"`
	Location             []*BucketAgg  `json:"location,omitempty" url:"location,omitempty"`
	SourceType           []*BucketAgg  `json:"source_type,omitempty" url:"source_type,omitempty"`
	Region               []*BucketAgg  `json:"region,omitempty" url:"region,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectEntitiesAggs) GetHitCount() []*BucketAgg {
	if p == nil {
		return nil
	}
	return p.HitCount
}

func (p *ProjectEntitiesAggs) GetCountry() []*BucketAgg {
	if p == nil {
		return nil
	}
	return p.Country
}

func (p *ProjectEntitiesAggs) GetUpstreamCountry() []*BucketAgg {
	if p == nil {
		return nil
	}
	return p.UpstreamCountry
}

func (p *ProjectEntitiesAggs) GetUpstreamCountryTiers() *TierCountAgg {
	if p == nil {
		return nil
	}
	return p.UpstreamCountryTiers
}

func (p *ProjectEntitiesAggs) GetRisk() []*BucketAgg {
	if p == nil {
		return nil
	}
	return p.Risk
}

func (p *ProjectEntitiesAggs) GetUpstreamRisk() []*BucketAgg {
	if p == nil {
		return nil
	}
	return p.UpstreamRisk
}

func (p *ProjectEntitiesAggs) GetUpstreamRiskTiers() *TierCountAgg {
	if p == nil {
		return nil
	}
	return p.UpstreamRiskTiers
}

func (p *ProjectEntitiesAggs) GetSource() []*BucketAgg {
	if p == nil {
		return nil
	}
	return p.Source
}

func (p *ProjectEntitiesAggs) GetBusinessPurpose() []*BucketAgg {
	if p == nil {
		return nil
	}
	return p.BusinessPurpose
}

func (p *ProjectEntitiesAggs) GetTagIds() []*BucketAgg {
	if p == nil {
		return nil
	}
	return p.TagIds
}

func (p *ProjectEntitiesAggs) GetCaseStatuses() []*BucketAgg {
	if p == nil {
		return nil
	}
	return p.CaseStatuses
}

func (p *ProjectEntitiesAggs) GetShipmentCounts() []*BucketAgg {
	if p == nil {
		return nil
	}
	return p.ShipmentCounts
}

func (p *ProjectEntitiesAggs) GetShippedHsCodes() *HsCodeAgg {
	if p == nil {
		return nil
	}
	return p.ShippedHsCodes
}

func (p *ProjectEntitiesAggs) GetReceivedHsCodes() *HsCodeAgg {
	if p == nil {
		return nil
	}
	return p.ReceivedHsCodes
}

func (p *ProjectEntitiesAggs) GetCombinedHsCodes() *HsCodeAgg {
	if p == nil {
		return nil
	}
	return p.CombinedHsCodes
}

func (p *ProjectEntitiesAggs) GetMatchResults() []*BucketAgg {
	if p == nil {
		return nil
	}
	return p.MatchResults
}

func (p *ProjectEntitiesAggs) GetCustomFields() []*BucketAgg {
	if p == nil {
		return nil
	}
	return p.CustomFields
}

func (p *ProjectEntitiesAggs) GetCustomFieldsCount() *IntKeyValue {
	if p == nil {
		return nil
	}
	return p.CustomFieldsCount
}

func (p *ProjectEntitiesAggs) GetLocation() []*BucketAgg {
	if p == nil {
		return nil
	}
	return p.Location
}

func (p *ProjectEntitiesAggs) GetSourceType() []*BucketAgg {
	if p == nil {
		return nil
	}
	return p.SourceType
}

func (p *ProjectEntitiesAggs) GetRegion() []*BucketAgg {
	if p == nil {
		return nil
	}
	return p.Region
}

func (p *ProjectEntitiesAggs) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectEntitiesAggs) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectEntitiesAggs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectEntitiesAggs(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectEntitiesAggs) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Aggregations for entities in a project. Possible values are - hit_count Cardinality of unique entities. - country Count of entities per country. - upstream_country Count of entities per upstream country. - upstream_country_tiers Count of entities per upstream country, by tier. - upstream_risk Count of entities per upstream risk factor. - upstream_risk_tiers Count of entities per upstream risk factor, by tier. - source Count of entities per source. - business_purpose Count of entities per business purpose. - receiver_of Total number of shipments received by entities. - shipper_of Total number of shipments shipped by entities. - received_hs_codes Count of entities and shipments received per HS code. - shipped_hs_codes Count of entities and shipments shipped per HS code. - combined_hs_codes Count of entities and shipments shipped or received per HS code. - location Count of entities per grid cell within the specified `bounds` filter. Each cell corresponds to a [map tile](https://en.wikipedia.org/wiki/Tiled_web_map) as used by many online map sites. Each cell is labeled using a "{zoom}/{x}/{y}" format, where zoom is an automatically-selected precision. To use this aggregation, both `filters=bounds` and `geo_facets=true` query parameters must be provided. - <risk> where <risk> is a [risk factor](/sayari-library/ontology/risk-factors) ID. Count of entities per risk factor.
type ProjectEntitiesAggsDefinition = string

type ProjectEntitiesFilter struct {
	// Filter by [risk factor](/sayari-library/ontology/risk-factors) ID.
	Risk []Risk `json:"risk,omitempty" url:"risk,omitempty"`
	// Filter by upstream (supply chain) [risk factor](/sayari-library/ontology/risk-factors) ID.
	UpstreamRisk []Risk `json:"upstream_risk,omitempty" url:"upstream_risk,omitempty"`
	// Filter by upstream (supply chain) tiers that has one or more risks
	UpstreamRiskTiers []UpstreamTiers `json:"upstream_risk_tiers,omitempty" url:"upstream_risk_tiers,omitempty"`
	// Filter by [country](/sayari-library/ontology/enumerated-types#country).
	Country []Country `json:"country,omitempty" url:"country,omitempty"`
	// Filter by upstream (supply chain) [country](/sayari-library/ontology/enumerated-types#country).
	UpstreamCountry []Country `json:"upstream_country,omitempty" url:"upstream_country,omitempty"`
	// Filter by upstream (supply chain) tiers that has one or more countries
	UpstreamCountryTiers []UpstreamTiers `json:"upstream_country_tiers,omitempty" url:"upstream_country_tiers,omitempty"`
	// Filter by HS code, HS code description, or business description.
	BusinessPurpose []string `json:"business_purpose,omitempty" url:"business_purpose,omitempty"`
	// Filter by entity label with fuzzy matching.
	LabelFuzzy []string `json:"label.fuzzy,omitempty" url:"label.fuzzy,omitempty"`
	// Filter by entity city with fuzzy matching.
	CityFuzzy []string `json:"city.fuzzy,omitempty" url:"city.fuzzy,omitempty"`
	// Filter by entity address state with fuzzy matching.
	StateFuzzy []string `json:"state.fuzzy,omitempty" url:"state.fuzzy,omitempty"`
	// Filter by entity identifier attributes with fuzzy matching.
	IdentifierFuzzy []string `json:"identifier.fuzzy,omitempty" url:"identifier.fuzzy,omitempty"`
	// Filter by entity source ID.
	SourceExact []string `json:"source.exact,omitempty" url:"source.exact,omitempty"`
	// Filter by entity [company status](/sayari-library/ontology/enumerated-types#company-status).
	StatusExact []CompanyStatus `json:"status.exact,omitempty" url:"status.exact,omitempty"`
	// Filter by risk factor `category`, e.g. `sanctions`. At least one risk factor from each provided category must be present.
	RiskCategory []string `json:"risk_category,omitempty" url:"risk_category,omitempty"`
	// Filter by a geographical bounding box. The value is a pipe-delimited set of four values representing the top, left, bottom, and right sides of the bounding box, in that order. The pipes should be URL-encoded as `%7C`. The top coordinate must greater than the bottom coordinate, and the left coordinate must be less than the right coordinate. A sample is `55.680357237879136|-71.53607290158526|41.10876347746233|-40.963927098414736`
	Bounds *string `json:"bounds,omitempty" url:"bounds,omitempty"`
	// <Warning>This property is in beta and is subject to change. It is provided for early access and testing purposes only.</Warning> custom user key/value pairs (key must be prefixed with "custom_" and value must be "string" type)
	CustomFieldName []string `json:"custom_{field name},omitempty" url:"custom_{field name},omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectEntitiesFilter) GetRisk() []Risk {
	if p == nil {
		return nil
	}
	return p.Risk
}

func (p *ProjectEntitiesFilter) GetUpstreamRisk() []Risk {
	if p == nil {
		return nil
	}
	return p.UpstreamRisk
}

func (p *ProjectEntitiesFilter) GetUpstreamRiskTiers() []UpstreamTiers {
	if p == nil {
		return nil
	}
	return p.UpstreamRiskTiers
}

func (p *ProjectEntitiesFilter) GetCountry() []Country {
	if p == nil {
		return nil
	}
	return p.Country
}

func (p *ProjectEntitiesFilter) GetUpstreamCountry() []Country {
	if p == nil {
		return nil
	}
	return p.UpstreamCountry
}

func (p *ProjectEntitiesFilter) GetUpstreamCountryTiers() []UpstreamTiers {
	if p == nil {
		return nil
	}
	return p.UpstreamCountryTiers
}

func (p *ProjectEntitiesFilter) GetBusinessPurpose() []string {
	if p == nil {
		return nil
	}
	return p.BusinessPurpose
}

func (p *ProjectEntitiesFilter) GetLabelFuzzy() []string {
	if p == nil {
		return nil
	}
	return p.LabelFuzzy
}

func (p *ProjectEntitiesFilter) GetCityFuzzy() []string {
	if p == nil {
		return nil
	}
	return p.CityFuzzy
}

func (p *ProjectEntitiesFilter) GetStateFuzzy() []string {
	if p == nil {
		return nil
	}
	return p.StateFuzzy
}

func (p *ProjectEntitiesFilter) GetIdentifierFuzzy() []string {
	if p == nil {
		return nil
	}
	return p.IdentifierFuzzy
}

func (p *ProjectEntitiesFilter) GetSourceExact() []string {
	if p == nil {
		return nil
	}
	return p.SourceExact
}

func (p *ProjectEntitiesFilter) GetStatusExact() []CompanyStatus {
	if p == nil {
		return nil
	}
	return p.StatusExact
}

func (p *ProjectEntitiesFilter) GetRiskCategory() []string {
	if p == nil {
		return nil
	}
	return p.RiskCategory
}

func (p *ProjectEntitiesFilter) GetBounds() *string {
	if p == nil {
		return nil
	}
	return p.Bounds
}

func (p *ProjectEntitiesFilter) GetCustomFieldName() []string {
	if p == nil {
		return nil
	}
	return p.CustomFieldName
}

func (p *ProjectEntitiesFilter) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectEntitiesFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectEntitiesFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectEntitiesFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectEntitiesFilter) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectEntity struct {
	Id      string `json:"id" url:"id"`
	Project string `json:"project" url:"project"`
	// Entity label (display name).
	Label     string `json:"label" url:"label"`
	Created   string `json:"created" url:"created"`
	Updated   string `json:"updated" url:"updated"`
	UpdatedBy string `json:"updated_by" url:"updated_by"`
	// Will be 0.
	Version int `json:"version" url:"version"`
	// Entity ID.
	EntityId   string   `json:"entity_id" url:"entity_id"`
	TagIds     []string `json:"tag_ids,omitempty" url:"tag_ids,omitempty"`
	CaseStatus string   `json:"case_status" url:"case_status"`
	// <Warning>This property is in beta and is subject to change. It is provided for early access and testing purposes only.</Warning> custom user key/value pairs (key must be prefixed with "custom_" and value must be "string" type)
	CustomFields  interface{} `json:"custom_fields,omitempty" url:"custom_fields,omitempty"`
	MatchStrength interface{} `json:"match_strength,omitempty" url:"match_strength,omitempty"`
	// HS codes shipped by the entity.
	ShippedHsCodes []string `json:"shipped_hs_codes,omitempty" url:"shipped_hs_codes,omitempty"`
	// HS codes received by the entity.
	ReceivedHsCodes []string `json:"received_hs_codes,omitempty" url:"received_hs_codes,omitempty"`
	// HS codes shipped or received by the entity.
	CombinedHsCodes []string `json:"combined_hs_codes,omitempty" url:"combined_hs_codes,omitempty"`
	// Counts of sent and received shipments for this entity and its match group.
	TradeCountInclMg *TradeCount            `json:"trade_count_incl_mg,omitempty" url:"trade_count_incl_mg,omitempty"`
	Upstream         *ProjectEntityUpstream `json:"upstream,omitempty" url:"upstream,omitempty"`
	Summary          *CoreEntity            `json:"summary,omitempty" url:"summary,omitempty"`
	Psa              *PsaSummary            `json:"psa,omitempty" url:"psa,omitempty"`
	type_            string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectEntity) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *ProjectEntity) GetProject() string {
	if p == nil {
		return ""
	}
	return p.Project
}

func (p *ProjectEntity) GetLabel() string {
	if p == nil {
		return ""
	}
	return p.Label
}

func (p *ProjectEntity) GetCreated() string {
	if p == nil {
		return ""
	}
	return p.Created
}

func (p *ProjectEntity) GetUpdated() string {
	if p == nil {
		return ""
	}
	return p.Updated
}

func (p *ProjectEntity) GetUpdatedBy() string {
	if p == nil {
		return ""
	}
	return p.UpdatedBy
}

func (p *ProjectEntity) GetVersion() int {
	if p == nil {
		return 0
	}
	return p.Version
}

func (p *ProjectEntity) GetEntityId() string {
	if p == nil {
		return ""
	}
	return p.EntityId
}

func (p *ProjectEntity) GetTagIds() []string {
	if p == nil {
		return nil
	}
	return p.TagIds
}

func (p *ProjectEntity) GetCaseStatus() string {
	if p == nil {
		return ""
	}
	return p.CaseStatus
}

func (p *ProjectEntity) GetCustomFields() interface{} {
	if p == nil {
		return nil
	}
	return p.CustomFields
}

func (p *ProjectEntity) GetMatchStrength() interface{} {
	if p == nil {
		return nil
	}
	return p.MatchStrength
}

func (p *ProjectEntity) GetShippedHsCodes() []string {
	if p == nil {
		return nil
	}
	return p.ShippedHsCodes
}

func (p *ProjectEntity) GetReceivedHsCodes() []string {
	if p == nil {
		return nil
	}
	return p.ReceivedHsCodes
}

func (p *ProjectEntity) GetCombinedHsCodes() []string {
	if p == nil {
		return nil
	}
	return p.CombinedHsCodes
}

func (p *ProjectEntity) GetTradeCountInclMg() *TradeCount {
	if p == nil {
		return nil
	}
	return p.TradeCountInclMg
}

func (p *ProjectEntity) GetUpstream() *ProjectEntityUpstream {
	if p == nil {
		return nil
	}
	return p.Upstream
}

func (p *ProjectEntity) GetSummary() *CoreEntity {
	if p == nil {
		return nil
	}
	return p.Summary
}

func (p *ProjectEntity) GetPsa() *PsaSummary {
	if p == nil {
		return nil
	}
	return p.Psa
}

func (p *ProjectEntity) Type() string {
	return p.type_
}

func (p *ProjectEntity) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectEntity) UnmarshalJSON(data []byte) error {
	type embed ProjectEntity
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = ProjectEntity(unmarshaler.embed)
	if unmarshaler.Type != "entity" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "entity", unmarshaler.Type)
	}
	p.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *p, "type")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectEntity) MarshalJSON() ([]byte, error) {
	type embed ProjectEntity
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*p),
		Type:  "entity",
	}
	return json.Marshal(marshaler)
}

func (p *ProjectEntity) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectEntityUpstream struct {
	Risk             []Risk              `json:"risk,omitempty" url:"risk,omitempty"`
	Countries        []Country           `json:"countries,omitempty" url:"countries,omitempty"`
	Entities         int                 `json:"entities" url:"entities"`
	MatchHasUpstream map[string]bool     `json:"match_has_upstream,omitempty" url:"match_has_upstream,omitempty"`
	MatchProducts    map[string][]string `json:"match_products,omitempty" url:"match_products,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectEntityUpstream) GetRisk() []Risk {
	if p == nil {
		return nil
	}
	return p.Risk
}

func (p *ProjectEntityUpstream) GetCountries() []Country {
	if p == nil {
		return nil
	}
	return p.Countries
}

func (p *ProjectEntityUpstream) GetEntities() int {
	if p == nil {
		return 0
	}
	return p.Entities
}

func (p *ProjectEntityUpstream) GetMatchHasUpstream() map[string]bool {
	if p == nil {
		return nil
	}
	return p.MatchHasUpstream
}

func (p *ProjectEntityUpstream) GetMatchProducts() map[string][]string {
	if p == nil {
		return nil
	}
	return p.MatchProducts
}

func (p *ProjectEntityUpstream) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectEntityUpstream) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectEntityUpstream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectEntityUpstream(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectEntityUpstream) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectShareOnCreate struct {
	Org Role `json:"org" url:"org"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectShareOnCreate) GetOrg() Role {
	if p == nil {
		return ""
	}
	return p.Org
}

func (p *ProjectShareOnCreate) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectShareOnCreate) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectShareOnCreate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectShareOnCreate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectShareOnCreate) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectWithMembers struct {
	// Unique project identifier.
	Id string `json:"id" url:"id"`
	// Most recently set name for the project.
	Label string `json:"label" url:"label"`
	// Whether the project is archived. Archival is a soft delete.
	Archived bool           `json:"archived" url:"archived"`
	Created  string         `json:"created" url:"created"`
	Updated  string         `json:"updated" url:"updated"`
	Counts   *ProjectCounts `json:"counts,omitempty" url:"counts,omitempty"`
	Members  []*RoleMember  `json:"members,omitempty" url:"members,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectWithMembers) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *ProjectWithMembers) GetLabel() string {
	if p == nil {
		return ""
	}
	return p.Label
}

func (p *ProjectWithMembers) GetArchived() bool {
	if p == nil {
		return false
	}
	return p.Archived
}

func (p *ProjectWithMembers) GetCreated() string {
	if p == nil {
		return ""
	}
	return p.Created
}

func (p *ProjectWithMembers) GetUpdated() string {
	if p == nil {
		return ""
	}
	return p.Updated
}

func (p *ProjectWithMembers) GetCounts() *ProjectCounts {
	if p == nil {
		return nil
	}
	return p.Counts
}

func (p *ProjectWithMembers) GetMembers() []*RoleMember {
	if p == nil {
		return nil
	}
	return p.Members
}

func (p *ProjectWithMembers) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectWithMembers) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectWithMembers
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectWithMembers(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectWithMembers) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Role enum describes the access levels a user has to a project and its contents.
type Role string

const (
	// The user can view the project and its contents.
	RoleViewer Role = "viewer"
	// The user can view and edit the project and its contents.
	RoleEditor Role = "editor"
	// The user can view, edit, and delete the project and its contents.
	RoleAdmin Role = "admin"
)

func NewRoleFromString(s string) (Role, error) {
	switch s {
	case "viewer":
		return RoleViewer, nil
	case "editor":
		return RoleEditor, nil
	case "admin":
		return RoleAdmin, nil
	}
	var t Role
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r Role) Ptr() *Role {
	return &r
}

type RoleMember struct {
	Id      string         `json:"id" url:"id"`
	Type    RoleMemberType `json:"type" url:"type"`
	Role    Role           `json:"role" url:"role"`
	Created string         `json:"created" url:"created"`
	Updated string         `json:"updated" url:"updated"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RoleMember) GetId() string {
	if r == nil {
		return ""
	}
	return r.Id
}

func (r *RoleMember) GetType() RoleMemberType {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *RoleMember) GetRole() Role {
	if r == nil {
		return ""
	}
	return r.Role
}

func (r *RoleMember) GetCreated() string {
	if r == nil {
		return ""
	}
	return r.Created
}

func (r *RoleMember) GetUpdated() string {
	if r == nil {
		return ""
	}
	return r.Updated
}

func (r *RoleMember) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RoleMember) UnmarshalJSON(data []byte) error {
	type unmarshaler RoleMember
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoleMember(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoleMember) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Role member type enum describes how access is granted to a project and its contents
type RoleMemberType string

const (
	// The access is granted to a user.
	RoleMemberTypeUser RoleMemberType = "user"
	// The access is granted to a group.
	RoleMemberTypeGroup RoleMemberType = "group"
)

func NewRoleMemberTypeFromString(s string) (RoleMemberType, error) {
	switch s {
	case "user":
		return RoleMemberTypeUser, nil
	case "group":
		return RoleMemberTypeGroup, nil
	}
	var t RoleMemberType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RoleMemberType) Ptr() *RoleMemberType {
	return &r
}

// Defines a sort order on a field, either ascending or descending. The value should begin with a '-' to indicate a descending sort, followed by a field name to sort on.
type SortField string

const (
	// The date the entity was saved to the project, ascending.
	SortFieldCreatedAsc SortField = "created"
	// The date the entity was saved to the project, descending.
	SortFieldCreatedDesc SortField = "-created"
	// The unique identifier of the saved entity within the project, e.g. `12200`, ascending.
	SortFieldIdAsc SortField = "saved_resource_id"
	// The unique identifier of the saved entity within the project, e.g. `12200`, descending.
	SortFieldIdDesc SortField = "-saved_resource_id"
	// The unique identifier of the entity, e.g. `pLH5fpfZoWTiS1z8ieSTDQ`, ascending.
	SortFieldEntityIdAsc SortField = "entity_id"
	// The unique identifier of the entity, e.g. `pLH5fpfZoWTiS1z8ieSTDQ`, descending.
	SortFieldEntityIdDesc SortField = "-entity_id"
	// The [country](/sayari-library/ontology/enumerated-types#country) of the entity, ascending.
	SortFieldCountryAsc SortField = "country"
	// The [country](/sayari-library/ontology/enumerated-types#country) of the entity, descending.
	SortFieldCountryDesc SortField = "-country"
	// The most recent [company status](/sayari-library/ontology/enumerated-types#company-status) of the entity, ascending.
	SortFieldStatusAsc SortField = "latest_status"
	// The most recent [company status](/sayari-library/ontology/enumerated-types#company-status) of the entity, descending.
	SortFieldStatusDesc SortField = "-latest_status"
	// The label (display name) of the entity, ascending.
	SortFieldLabelAsc SortField = "label"
	// The label (display name) of the entity, descending.
	SortFieldLabelDesc SortField = "-label"
	// <Warning>This sorting option is in beta and is subject to change. It is provided for early access and testing purposes only.</Warning> One of the custom fields provided by the user, ascending.
	SortFieldCustomFieldsAsc SortField = "custom_{field name}"
	// <Warning>This sorting option is in beta and is subject to change. It is provided for early access and testing purposes only.</Warning> One of the custom fields provided by the user, descending.
	SortFieldCustomFieldsDesc SortField = "-custom_{field name}"
	// The number of shipments the entity has received, ascending.
	SortFieldReceiverOfAcc SortField = "receiver_of"
	// The number of shipments the entity has received, descending.
	SortFieldReceiverOfDesc SortField = "-receiver_of"
	// The number of shipments the entity has shipped, ascending.
	SortFieldShipperOfAsc SortField = "shipper_of"
	// The number of shipments the entity has shipped, descending.
	SortFieldShipperOfDesc SortField = "-shipper_of"
	// The number of upstream entities in the supply chain of the entity, ascending.
	SortFieldUpstreamEntitiesAsc SortField = "upstream_entities"
	// The number of upstream entities in the supply chain of the entity, descending.
	SortFieldUpstreamEntitiesDesc SortField = "-upstream_entities"
)

func NewSortFieldFromString(s string) (SortField, error) {
	switch s {
	case "created":
		return SortFieldCreatedAsc, nil
	case "-created":
		return SortFieldCreatedDesc, nil
	case "saved_resource_id":
		return SortFieldIdAsc, nil
	case "-saved_resource_id":
		return SortFieldIdDesc, nil
	case "entity_id":
		return SortFieldEntityIdAsc, nil
	case "-entity_id":
		return SortFieldEntityIdDesc, nil
	case "country":
		return SortFieldCountryAsc, nil
	case "-country":
		return SortFieldCountryDesc, nil
	case "latest_status":
		return SortFieldStatusAsc, nil
	case "-latest_status":
		return SortFieldStatusDesc, nil
	case "label":
		return SortFieldLabelAsc, nil
	case "-label":
		return SortFieldLabelDesc, nil
	case "custom_{field name}":
		return SortFieldCustomFieldsAsc, nil
	case "-custom_{field name}":
		return SortFieldCustomFieldsDesc, nil
	case "receiver_of":
		return SortFieldReceiverOfAcc, nil
	case "-receiver_of":
		return SortFieldReceiverOfDesc, nil
	case "shipper_of":
		return SortFieldShipperOfAsc, nil
	case "-shipper_of":
		return SortFieldShipperOfDesc, nil
	case "upstream_entities":
		return SortFieldUpstreamEntitiesAsc, nil
	case "-upstream_entities":
		return SortFieldUpstreamEntitiesDesc, nil
	}
	var t SortField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SortField) Ptr() *SortField {
	return &s
}

// Aggregation of counts by upstream supply chain tiers
type TierCount = map[*TierCountKeys]int

type TierCountAgg = map[string]TierCount

type TierCountKeys struct {
	UpstreamTiers           UpstreamTiers
	TotalCountStringLiteral string

	typ string
}

func NewTierCountKeysFromUpstreamTiers(value UpstreamTiers) *TierCountKeys {
	return &TierCountKeys{typ: "UpstreamTiers", UpstreamTiers: value}
}

func NewTierCountKeysWithTotalCountStringLiteral() *TierCountKeys {
	return &TierCountKeys{typ: "TotalCountStringLiteral", TotalCountStringLiteral: "totalCount"}
}

func (t *TierCountKeys) GetUpstreamTiers() UpstreamTiers {
	if t == nil {
		return ""
	}
	return t.UpstreamTiers
}

func (t *TierCountKeys) UnmarshalJSON(data []byte) error {
	var valueUpstreamTiers UpstreamTiers
	if err := json.Unmarshal(data, &valueUpstreamTiers); err == nil {
		t.typ = "UpstreamTiers"
		t.UpstreamTiers = valueUpstreamTiers
		return nil
	}
	var valueTotalCountStringLiteral string
	if err := json.Unmarshal(data, &valueTotalCountStringLiteral); err == nil {
		t.typ = "TotalCountStringLiteral"
		t.TotalCountStringLiteral = valueTotalCountStringLiteral
		if t.TotalCountStringLiteral != "totalCount" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "totalCount", valueTotalCountStringLiteral)
		}
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TierCountKeys) MarshalJSON() ([]byte, error) {
	if t.typ == "UpstreamTiers" || t.UpstreamTiers != "" {
		return json.Marshal(t.UpstreamTiers)
	}
	if t.typ == "TotalCountStringLiteral" || t.TotalCountStringLiteral != "" {
		return json.Marshal("totalCount")
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TierCountKeysVisitor interface {
	VisitUpstreamTiers(UpstreamTiers) error
	VisitTotalCountStringLiteral(string) error
}

func (t *TierCountKeys) Accept(visitor TierCountKeysVisitor) error {
	if t.typ == "UpstreamTiers" || t.UpstreamTiers != "" {
		return visitor.VisitUpstreamTiers(t.UpstreamTiers)
	}
	if t.typ == "TotalCountStringLiteral" || t.TotalCountStringLiteral != "" {
		return visitor.VisitTotalCountStringLiteral(t.TotalCountStringLiteral)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TradeCount struct {
	ReceiverOf int `json:"receiver_of" url:"receiver_of"`
	ShipperOf  int `json:"shipper_of" url:"shipper_of"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TradeCount) GetReceiverOf() int {
	if t == nil {
		return 0
	}
	return t.ReceiverOf
}

func (t *TradeCount) GetShipperOf() int {
	if t == nil {
		return 0
	}
	return t.ShipperOf
}

func (t *TradeCount) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TradeCount) UnmarshalJSON(data []byte) error {
	type unmarshaler TradeCount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TradeCount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TradeCount) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type UpstreamTiers string

const (
	UpstreamTiersTier1 UpstreamTiers = "tier1"
	UpstreamTiersTier2 UpstreamTiers = "tier2"
	UpstreamTiersTier3 UpstreamTiers = "tier3"
	UpstreamTiersTier4 UpstreamTiers = "tier4"
)

func NewUpstreamTiersFromString(s string) (UpstreamTiers, error) {
	switch s {
	case "tier1":
		return UpstreamTiersTier1, nil
	case "tier2":
		return UpstreamTiersTier2, nil
	case "tier3":
		return UpstreamTiersTier3, nil
	case "tier4":
		return UpstreamTiersTier4, nil
	}
	var t UpstreamTiers
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpstreamTiers) Ptr() *UpstreamTiers {
	return &u
}
