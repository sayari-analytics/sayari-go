// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"

	internal "github.com/sayari-analytics/sayari-go/generated/go/internal"
)

type GetProjectEntitiesRequest struct {
	// Filter by entity IDs
	EntityId []string `json:"-" url:"entity_id,omitempty"`
	// Filter by upload IDs
	Uploads []string `json:"-" url:"uploads,omitempty"`
	// Filter by case status
	CaseStatus []CaseStatus `json:"-" url:"case_status,omitempty"`
	// Filter by tag IDs
	Tags []string `json:"-" url:"tags,omitempty"`
	// Filter by match count
	MatchCount *MatchCount `json:"-" url:"match_count,omitempty"`
	// Filter by match strength
	MatchStrength []MatchStrengthEnum `json:"-" url:"match_strength,omitempty"`
	// Filter by entity types
	EntityTypes []string `json:"-" url:"entity_types,omitempty"`
	// Include geo facets
	GeoFacets *bool `json:"-" url:"geo_facets,omitempty"`
	// Use exact matching
	ExactMatch *bool `json:"-" url:"exact_match,omitempty"`
	// Filter by HS codes
	HsCodes []string `json:"-" url:"hs_codes,omitempty"`
	// Filter by received HS codes
	ReceivedHsCodes []string `json:"-" url:"received_hs_codes,omitempty"`
	// Filter by shipped HS codes
	ShippedHsCodes []string `json:"-" url:"shipped_hs_codes,omitempty"`
	// Filter by upstream product
	UpstreamProduct []string `json:"-" url:"upstream_product,omitempty"`
	// Maximum number of results to return
	Limit *int `json:"-" url:"limit,omitempty"`
	// Pagination token
	Token *string `json:"-" url:"token,omitempty"`
	// Sort fields
	Sort []string `json:"-" url:"sort,omitempty"`
	// Fields to aggregate
	Aggregations []string `json:"-" url:"aggregations,omitempty"`
	// Number of aggregation buckets
	NumAggregationBuckets *int `json:"-" url:"num_aggregation_buckets,omitempty"`
	// List of risk factors to filter by
	Risk []Risk `json:"-" url:"risk,omitempty"`
	// List of risk categories to filter by. An entity matches if it has any risk factor belonging to one of the specified categories
	RiskCategory []RiskCategory `json:"-" url:"risk_category,omitempty"`
}

type GetProjectEntityRequest struct {
	// Filter by entity IDs
	EntityId []string `json:"-" url:"entity_id,omitempty"`
	// Filter by upload IDs
	Uploads []string `json:"-" url:"uploads,omitempty"`
	// Filter by case status
	CaseStatus []CaseStatus `json:"-" url:"case_status,omitempty"`
	// Filter by tag IDs
	Tags []string `json:"-" url:"tags,omitempty"`
	// Filter by match count
	MatchCount *MatchCount `json:"-" url:"match_count,omitempty"`
	// Filter by match strength
	MatchStrength []MatchStrengthEnum `json:"-" url:"match_strength,omitempty"`
	// Filter by entity types
	EntityTypes []string `json:"-" url:"entity_types,omitempty"`
	// List of risk factors to filter by
	Risk []Risk `json:"-" url:"risk,omitempty"`
	// List of risk categories to filter by. An entity matches if it has any risk factor belonging to one of the specified categories
	RiskCategory []RiskCategory `json:"-" url:"risk_category,omitempty"`
}

type ProjectEntitySupplyChainRequest struct {
	// Product root edge filter. Filters results to include only trade relationships where the associated component is part of the specified product's blueprint or is a sub-component of that product.
	Product []string `json:"-" url:"product,omitempty"`
	// Product root edge filter. Filters results to exclude any trade relationships where the associated component is part of the specified product's blueprint or is a sub-component of that product.
	NotProduct []string `json:"-" url:"-product,omitempty"`
	// Risk leaf node filter. Only return supply chains that end with a supplier that has 1+ of the specified risk factors.
	Risk []Risk `json:"-" url:"risk,omitempty"`
	// Risk leaf node filter. Only return supply chains that end with a supplier that has none of the specified risk factors.
	NotRisk []Risk `json:"-" url:"-risk,omitempty"`
	// Country leaf node filter. Only return supply chains that end with a supplier in 1+ of the specified countries.
	Countries []Country `json:"-" url:"countries,omitempty"`
	// Country leaf node filter. Only return supply chains that end with a supplier in none of the specified countries.
	NotCountries []Country `json:"-" url:"-countries,omitempty"`
	// Filters supply chain paths where 1+ shipment country from any tier matches the provided values.
	ShipmentCountry []Country `json:"-" url:"shipment_country,omitempty"`
	// Filters supply chain paths where none of the shipment countries from any tier matches the provided values.
	NotShipmentCountry []Country `json:"-" url:"-shipment_country,omitempty"`
	// Filters supply chain paths where 1+ shipment country from tier 1 matches the provided values.
	Tier1ShipmentCountry []Country `json:"-" url:"tier1_shipment_country,omitempty"`
	// Filters supply chain paths where 1+ shipment country from tier 2 matches the provided values.
	Tier2ShipmentCountry []Country `json:"-" url:"tier2_shipment_country,omitempty"`
	// Filters supply chain paths where 1+ shipment country from tier 3 matches the provided values.
	Tier3ShipmentCountry []Country `json:"-" url:"tier3_shipment_country,omitempty"`
	// Filters supply chain paths where 1+ shipment country from tier 4 matches the provided values.
	Tier4ShipmentCountry []Country `json:"-" url:"tier4_shipment_country,omitempty"`
	// Filters supply chain paths where 1+ shipment country from tier 5 matches the provided values.
	Tier5ShipmentCountry []Country `json:"-" url:"tier5_shipment_country,omitempty"`
	// Component edge filter. Only return supply chains that contain at least one edge with 1+ of the specified HS codes.
	Component []string `json:"-" url:"component,omitempty"`
	// Component edge filter. Only return supply chains that contain no edges with any of the specified HS codes.
	NotComponent []string `json:"-" url:"-component,omitempty"`
	// Minimum date edge filter in <YYYY-MM-DD> format. Only return supply chains with edge dates that are greater than or equal to this date.
	MinDate *string `json:"-" url:"min_date,omitempty"`
	// Maximum date edge filter in <YYYY-MM-DD> format. Only return supply chains with edge dates that are less than or equal to this date.
	MaxDate *string `json:"-" url:"max_date,omitempty"`
	// The maximum depth of the traversal, from 1 to 4 inclusive. Default is 4. Reduce if query is timing out.
	MaxDepth *int `json:"-" url:"max_depth,omitempty"`
	// The maximum number of results to return. Default is no limit.
	Limit *int `json:"-" url:"limit,omitempty"`
}

type ProjectEntitySupplyChainSummaryRequest struct {
	// Product root edge filter. Filters results to include only trade relationships where the associated component is part of the specified product's blueprint or is a sub-component of that product.
	Product []string `json:"-" url:"product,omitempty"`
	// Product root edge filter. Filters results to exclude any trade relationships where the associated component is part of the specified product's blueprint or is a sub-component of that product.
	NotProduct []string `json:"-" url:"-product,omitempty"`
	// Risk leaf node filter. Only return supply chains that end with a supplier that has 1+ of the specified risk factors.
	RiskFactors []Risk `json:"-" url:"risk_factors,omitempty"`
	// Risk leaf node filter. Only return supply chains that end with a supplier that has none of the specified risk factors.
	NotRisk []Risk `json:"-" url:"-risk_factors,omitempty"`
	// Country leaf node filter. Only return supply chains that end with a supplier in 1+ of the specified countries.
	Countries []Country `json:"-" url:"countries,omitempty"`
	// Country leaf node filter. Only return supply chains that end with a supplier in none of the specified countries.
	NotCountries []Country `json:"-" url:"-countries,omitempty"`
	// Component edge filter. Only return supply chains that contain at least one edge with 1+ of the specified HS codes.
	Component []string `json:"-" url:"component,omitempty"`
	// Component edge filter. Only return supply chains that contain no edges with any of the specified HS codes.
	NotComponent []string `json:"-" url:"-component,omitempty"`
	// Minimum date edge filter in <YYYY-MM-DD> format. Only return supply chains with edge dates that are greater than or equal to this date.
	MinDate *string `json:"-" url:"min_date,omitempty"`
	// Maximum date edge filter in <YYYY-MM-DD> format. Only return supply chains with edge dates that are less than or equal to this date.
	MaxDate *string `json:"-" url:"max_date,omitempty"`
	// The maximum depth of the traversal, from 1 to 4 inclusive. Default is 4. Reduce if query is timing out.
	MaxDepth *int `json:"-" url:"max_depth,omitempty"`
	// The maximum number of results to return. Default is no limit.
	Limit *int `json:"-" url:"limit,omitempty"`
}

type Address struct {
	Value    string    `json:"value" url:"value"`
	Country  *string   `json:"country,omitempty" url:"country,omitempty"`
	City     *string   `json:"city,omitempty" url:"city,omitempty"`
	State    *string   `json:"state,omitempty" url:"state,omitempty"`
	Location *Location `json:"location,omitempty" url:"location,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Address) GetValue() string {
	if a == nil {
		return ""
	}
	return a.Value
}

func (a *Address) GetCountry() *string {
	if a == nil {
		return nil
	}
	return a.Country
}

func (a *Address) GetCity() *string {
	if a == nil {
		return nil
	}
	return a.City
}

func (a *Address) GetState() *string {
	if a == nil {
		return nil
	}
	return a.State
}

func (a *Address) GetLocation() *Location {
	if a == nil {
		return nil
	}
	return a.Location
}

func (a *Address) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AttributeType struct {
	Type       string `json:"type" url:"type"`
	Resolution bool   `json:"resolution" url:"resolution"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AttributeType) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AttributeType) GetResolution() bool {
	if a == nil {
		return false
	}
	return a.Resolution
}

func (a *AttributeType) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AttributeType) UnmarshalJSON(data []byte) error {
	type unmarshaler AttributeType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AttributeType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AttributeType) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AttributeTypesResponse struct {
	Data []*AttributeType `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AttributeTypesResponse) GetData() []*AttributeType {
	if a == nil {
		return nil
	}
	return a.Data
}

func (a *AttributeTypesResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AttributeTypesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AttributeTypesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AttributeTypesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AttributeTypesResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AttributeValue struct {
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AttributeValue) GetValue() string {
	if a == nil {
		return ""
	}
	return a.Value
}

func (a *AttributeValue) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AttributeValue) UnmarshalJSON(data []byte) error {
	type unmarshaler AttributeValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AttributeValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AttributeValue) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AttributeValues struct {
	MatchResolution bool              `json:"match_resolution" url:"match_resolution"`
	Values          []*AttributeValue `json:"values,omitempty" url:"values,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AttributeValues) GetMatchResolution() bool {
	if a == nil {
		return false
	}
	return a.MatchResolution
}

func (a *AttributeValues) GetValues() []*AttributeValue {
	if a == nil {
		return nil
	}
	return a.Values
}

func (a *AttributeValues) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AttributeValues) UnmarshalJSON(data []byte) error {
	type unmarshaler AttributeValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AttributeValues(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AttributeValues) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AttributesResponse struct {
	Data []*GroupedAttribute `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AttributesResponse) GetData() []*GroupedAttribute {
	if a == nil {
		return nil
	}
	return a.Data
}

func (a *AttributesResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AttributesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AttributesResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BusinessPurpose struct {
	Code     string `json:"code" url:"code"`
	Standard string `json:"standard" url:"standard"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BusinessPurpose) GetCode() string {
	if b == nil {
		return ""
	}
	return b.Code
}

func (b *BusinessPurpose) GetStandard() string {
	if b == nil {
		return ""
	}
	return b.Standard
}

func (b *BusinessPurpose) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessPurpose) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessPurpose
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessPurpose(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessPurpose) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CaseInfo struct {
	Status     *CaseStatus `json:"status,omitempty" url:"status,omitempty"`
	AssignedTo *string     `json:"assigned_to,omitempty" url:"assigned_to,omitempty"`
	Notes      *string     `json:"notes,omitempty" url:"notes,omitempty"`
	UpdatedAt  *string     `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	UpdatedBy  *string     `json:"updated_by,omitempty" url:"updated_by,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CaseInfo) GetStatus() *CaseStatus {
	if c == nil {
		return nil
	}
	return c.Status
}

func (c *CaseInfo) GetAssignedTo() *string {
	if c == nil {
		return nil
	}
	return c.AssignedTo
}

func (c *CaseInfo) GetNotes() *string {
	if c == nil {
		return nil
	}
	return c.Notes
}

func (c *CaseInfo) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CaseInfo) GetUpdatedBy() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedBy
}

func (c *CaseInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CaseInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler CaseInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CaseInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CaseInfo) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CaseStatus string

const (
	CaseStatusNotAssigned CaseStatus = "not_assigned"
	CaseStatusInReview    CaseStatus = "in_review"
	CaseStatusApproved    CaseStatus = "approved"
	CaseStatusRejected    CaseStatus = "rejected"
)

func NewCaseStatusFromString(s string) (CaseStatus, error) {
	switch s {
	case "not_assigned":
		return CaseStatusNotAssigned, nil
	case "in_review":
		return CaseStatusInReview, nil
	case "approved":
		return CaseStatusApproved, nil
	case "rejected":
		return CaseStatusRejected, nil
	}
	var t CaseStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CaseStatus) Ptr() *CaseStatus {
	return &c
}

type CountType string

const (
	CountTypeCoordinates            CountType = "coordinates"
	CountTypeUpstreamProductRisk    CountType = "upstream_product_risk"
	CountTypeUpstreamProductCountry CountType = "upstream_product_country"
)

func NewCountTypeFromString(s string) (CountType, error) {
	switch s {
	case "coordinates":
		return CountTypeCoordinates, nil
	case "upstream_product_risk":
		return CountTypeUpstreamProductRisk, nil
	case "upstream_product_country":
		return CountTypeUpstreamProductCountry, nil
	}
	var t CountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CountType) Ptr() *CountType {
	return &c
}

type CreateResolvedProjectEntityRequest struct {
	Identifier  []*StringOrNumber  `json:"identifier,omitempty" url:"identifier,omitempty"`
	Name        []string           `json:"name,omitempty" url:"name,omitempty"`
	Country     []Country          `json:"country,omitempty" url:"country,omitempty"`
	Address     []string           `json:"address,omitempty" url:"address,omitempty"`
	DateOfBirth []string           `json:"date_of_birth,omitempty" url:"date_of_birth,omitempty"`
	Contact     []*StringOrNumber  `json:"contact,omitempty" url:"contact,omitempty"`
	Type        []Entities         `json:"type,omitempty" url:"type,omitempty"`
	City        []string           `json:"city,omitempty" url:"city,omitempty"`
	State       []string           `json:"state,omitempty" url:"state,omitempty"`
	Profile     *ResolutionProfile `json:"profile,omitempty" url:"profile,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateResolvedProjectEntityRequest) GetIdentifier() []*StringOrNumber {
	if c == nil {
		return nil
	}
	return c.Identifier
}

func (c *CreateResolvedProjectEntityRequest) GetName() []string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateResolvedProjectEntityRequest) GetCountry() []Country {
	if c == nil {
		return nil
	}
	return c.Country
}

func (c *CreateResolvedProjectEntityRequest) GetAddress() []string {
	if c == nil {
		return nil
	}
	return c.Address
}

func (c *CreateResolvedProjectEntityRequest) GetDateOfBirth() []string {
	if c == nil {
		return nil
	}
	return c.DateOfBirth
}

func (c *CreateResolvedProjectEntityRequest) GetContact() []*StringOrNumber {
	if c == nil {
		return nil
	}
	return c.Contact
}

func (c *CreateResolvedProjectEntityRequest) GetType() []Entities {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CreateResolvedProjectEntityRequest) GetCity() []string {
	if c == nil {
		return nil
	}
	return c.City
}

func (c *CreateResolvedProjectEntityRequest) GetState() []string {
	if c == nil {
		return nil
	}
	return c.State
}

func (c *CreateResolvedProjectEntityRequest) GetProfile() *ResolutionProfile {
	if c == nil {
		return nil
	}
	return c.Profile
}

func (c *CreateResolvedProjectEntityRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateResolvedProjectEntityRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateResolvedProjectEntityRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateResolvedProjectEntityRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateResolvedProjectEntityRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type FacetBucket struct {
	Key      string `json:"key" url:"key"`
	DocCount int    `json:"doc_count" url:"doc_count"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FacetBucket) GetKey() string {
	if f == nil {
		return ""
	}
	return f.Key
}

func (f *FacetBucket) GetDocCount() int {
	if f == nil {
		return 0
	}
	return f.DocCount
}

func (f *FacetBucket) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FacetBucket) UnmarshalJSON(data []byte) error {
	type unmarshaler FacetBucket
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FacetBucket(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FacetBucket) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FacetsResponse struct {
	Data map[string][]*FacetBucket `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FacetsResponse) GetData() map[string][]*FacetBucket {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FacetsResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FacetsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FacetsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FacetsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FacetsResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type GroupedAttribute struct {
	Field           string                   `json:"field" url:"field"`
	MatchResolution bool                     `json:"match_resolution" url:"match_resolution"`
	Values          []*GroupedAttributeValue `json:"values,omitempty" url:"values,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedAttribute) GetField() string {
	if g == nil {
		return ""
	}
	return g.Field
}

func (g *GroupedAttribute) GetMatchResolution() bool {
	if g == nil {
		return false
	}
	return g.MatchResolution
}

func (g *GroupedAttribute) GetValues() []*GroupedAttributeValue {
	if g == nil {
		return nil
	}
	return g.Values
}

func (g *GroupedAttribute) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedAttribute) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedAttribute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedAttribute(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedAttribute) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedAttributeValue struct {
	Id    string `json:"id" url:"id"`
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedAttributeValue) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GroupedAttributeValue) GetValue() string {
	if g == nil {
		return ""
	}
	return g.Value
}

func (g *GroupedAttributeValue) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedAttributeValue) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedAttributeValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedAttributeValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedAttributeValue) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type Location struct {
	Lat float64 `json:"lat" url:"lat"`
	Lon float64 `json:"lon" url:"lon"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *Location) GetLat() float64 {
	if l == nil {
		return 0
	}
	return l.Lat
}

func (l *Location) GetLon() float64 {
	if l == nil {
		return 0
	}
	return l.Lon
}

func (l *Location) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Location) UnmarshalJSON(data []byte) error {
	type unmarshaler Location
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Location(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *Location) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type MatchCount string

const (
	MatchCountOne  MatchCount = "one"
	MatchCountMany MatchCount = "many"
)

func NewMatchCountFromString(s string) (MatchCount, error) {
	switch s {
	case "one":
		return MatchCountOne, nil
	case "many":
		return MatchCountMany, nil
	}
	var t MatchCount
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MatchCount) Ptr() *MatchCount {
	return &m
}

type MatchProfileEnum string

const (
	MatchProfileEnumCorporate MatchProfileEnum = "corporate"
	MatchProfileEnumSuppliers MatchProfileEnum = "suppliers"
	MatchProfileEnumScreen    MatchProfileEnum = "screen"
	MatchProfileEnumSearch    MatchProfileEnum = "search"
)

func NewMatchProfileEnumFromString(s string) (MatchProfileEnum, error) {
	switch s {
	case "corporate":
		return MatchProfileEnumCorporate, nil
	case "suppliers":
		return MatchProfileEnumSuppliers, nil
	case "screen":
		return MatchProfileEnumScreen, nil
	case "search":
		return MatchProfileEnumSearch, nil
	}
	var t MatchProfileEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MatchProfileEnum) Ptr() *MatchProfileEnum {
	return &m
}

type MatchStrengthEnum string

const (
	MatchStrengthEnumStrong  MatchStrengthEnum = "strong"
	MatchStrengthEnumPartial MatchStrengthEnum = "partial"
	MatchStrengthEnumNoMatch MatchStrengthEnum = "no_match"
	MatchStrengthEnumManual  MatchStrengthEnum = "manual"
)

func NewMatchStrengthEnumFromString(s string) (MatchStrengthEnum, error) {
	switch s {
	case "strong":
		return MatchStrengthEnumStrong, nil
	case "partial":
		return MatchStrengthEnumPartial, nil
	case "no_match":
		return MatchStrengthEnumNoMatch, nil
	case "manual":
		return MatchStrengthEnumManual, nil
	}
	var t MatchStrengthEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MatchStrengthEnum) Ptr() *MatchStrengthEnum {
	return &m
}

type MatchedAttributes struct {
	Name       []string `json:"name,omitempty" url:"name,omitempty"`
	Address    []string `json:"address,omitempty" url:"address,omitempty"`
	Contact    []string `json:"contact,omitempty" url:"contact,omitempty"`
	Country    []string `json:"country,omitempty" url:"country,omitempty"`
	Identifier []string `json:"identifier,omitempty" url:"identifier,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MatchedAttributes) GetName() []string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MatchedAttributes) GetAddress() []string {
	if m == nil {
		return nil
	}
	return m.Address
}

func (m *MatchedAttributes) GetContact() []string {
	if m == nil {
		return nil
	}
	return m.Contact
}

func (m *MatchedAttributes) GetCountry() []string {
	if m == nil {
		return nil
	}
	return m.Country
}

func (m *MatchedAttributes) GetIdentifier() []string {
	if m == nil {
		return nil
	}
	return m.Identifier
}

func (m *MatchedAttributes) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MatchedAttributes) UnmarshalJSON(data []byte) error {
	type unmarshaler MatchedAttributes
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MatchedAttributes(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MatchedAttributes) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ProductBucket struct {
	Key      string `json:"key" url:"key"`
	DocCount int    `json:"doc_count" url:"doc_count"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProductBucket) GetKey() string {
	if p == nil {
		return ""
	}
	return p.Key
}

func (p *ProductBucket) GetDocCount() int {
	if p == nil {
		return 0
	}
	return p.DocCount
}

func (p *ProductBucket) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProductBucket) UnmarshalJSON(data []byte) error {
	type unmarshaler ProductBucket
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProductBucket(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProductBucket) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProductCount struct {
	Product *string `json:"product,omitempty" url:"product,omitempty"`
	Count   int     `json:"count" url:"count"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProductCount) GetProduct() *string {
	if p == nil {
		return nil
	}
	return p.Product
}

func (p *ProductCount) GetCount() int {
	if p == nil {
		return 0
	}
	return p.Count
}

func (p *ProductCount) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProductCount) UnmarshalJSON(data []byte) error {
	type unmarshaler ProductCount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProductCount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProductCount) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProductMapping struct {
	Products []string `json:"products,omitempty" url:"products,omitempty"`
	State    string   `json:"state" url:"state"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProductMapping) GetProducts() []string {
	if p == nil {
		return nil
	}
	return p.Products
}

func (p *ProductMapping) GetState() string {
	if p == nil {
		return ""
	}
	return p.State
}

func (p *ProductMapping) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProductMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler ProductMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProductMapping(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProductMapping) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectEntitiesResponse struct {
	Limit     int                      `json:"limit" url:"limit"`
	Data      []*ProjectEntityResponse `json:"data,omitempty" url:"data,omitempty"`
	Size      *QualifiedCount          `json:"size,omitempty" url:"size,omitempty"`
	NextToken *string                  `json:"next_token,omitempty" url:"next_token,omitempty"`
	PrevToken *string                  `json:"prev_token,omitempty" url:"prev_token,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectEntitiesResponse) GetLimit() int {
	if p == nil {
		return 0
	}
	return p.Limit
}

func (p *ProjectEntitiesResponse) GetData() []*ProjectEntityResponse {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *ProjectEntitiesResponse) GetSize() *QualifiedCount {
	if p == nil {
		return nil
	}
	return p.Size
}

func (p *ProjectEntitiesResponse) GetNextToken() *string {
	if p == nil {
		return nil
	}
	return p.NextToken
}

func (p *ProjectEntitiesResponse) GetPrevToken() *string {
	if p == nil {
		return nil
	}
	return p.PrevToken
}

func (p *ProjectEntitiesResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectEntitiesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectEntitiesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectEntitiesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectEntitiesResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectEntityExistsResponseData struct {
	ProjectEntityId *string `json:"project_entity_id,omitempty" url:"project_entity_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectEntityExistsResponseData) GetProjectEntityId() *string {
	if p == nil {
		return nil
	}
	return p.ProjectEntityId
}

func (p *ProjectEntityExistsResponseData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectEntityExistsResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectEntityExistsResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectEntityExistsResponseData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectEntityExistsResponseData) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectEntityIdResponse struct {
	Data *ProjectEntityExistsResponseData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectEntityIdResponse) GetData() *ProjectEntityExistsResponseData {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *ProjectEntityIdResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectEntityIdResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectEntityIdResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectEntityIdResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectEntityIdResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectEntityMatchResponse struct {
	MatchId           string                 `json:"match_id" url:"match_id"`
	SayariEntityId    string                 `json:"sayari_entity_id" url:"sayari_entity_id"`
	Type              string                 `json:"type" url:"type"`
	Label             string                 `json:"label" url:"label"`
	MatchedAttributes *MatchedAttributes     `json:"matched_attributes,omitempty" url:"matched_attributes,omitempty"`
	Countries         []string               `json:"countries,omitempty" url:"countries,omitempty"`
	RiskCategories    []*ProjectRiskCategory `json:"risk_categories,omitempty" url:"risk_categories,omitempty"`
	RiskFactors       []*ProjectRiskFactor   `json:"risk_factors,omitempty" url:"risk_factors,omitempty"`
	BusinessPurpose   []*BusinessPurpose     `json:"business_purpose,omitempty" url:"business_purpose,omitempty"`
	Upstream          *UpstreamInfo          `json:"upstream,omitempty" url:"upstream,omitempty"`
	Sources           []*SourceField         `json:"sources,omitempty" url:"sources,omitempty"`
	Addresses         []*Address             `json:"addresses,omitempty" url:"addresses,omitempty"`
	HsCodes           []string               `json:"hs_codes,omitempty" url:"hs_codes,omitempty"`
	CreatedAt         string                 `json:"created_at" url:"created_at"`
	UpdatedAt         *string                `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	MatchProfile      *MatchProfileEnum      `json:"match_profile,omitempty" url:"match_profile,omitempty"`
	DeletedAt         *string                `json:"deleted_at,omitempty" url:"deleted_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectEntityMatchResponse) GetMatchId() string {
	if p == nil {
		return ""
	}
	return p.MatchId
}

func (p *ProjectEntityMatchResponse) GetSayariEntityId() string {
	if p == nil {
		return ""
	}
	return p.SayariEntityId
}

func (p *ProjectEntityMatchResponse) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *ProjectEntityMatchResponse) GetLabel() string {
	if p == nil {
		return ""
	}
	return p.Label
}

func (p *ProjectEntityMatchResponse) GetMatchedAttributes() *MatchedAttributes {
	if p == nil {
		return nil
	}
	return p.MatchedAttributes
}

func (p *ProjectEntityMatchResponse) GetCountries() []string {
	if p == nil {
		return nil
	}
	return p.Countries
}

func (p *ProjectEntityMatchResponse) GetRiskCategories() []*ProjectRiskCategory {
	if p == nil {
		return nil
	}
	return p.RiskCategories
}

func (p *ProjectEntityMatchResponse) GetRiskFactors() []*ProjectRiskFactor {
	if p == nil {
		return nil
	}
	return p.RiskFactors
}

func (p *ProjectEntityMatchResponse) GetBusinessPurpose() []*BusinessPurpose {
	if p == nil {
		return nil
	}
	return p.BusinessPurpose
}

func (p *ProjectEntityMatchResponse) GetUpstream() *UpstreamInfo {
	if p == nil {
		return nil
	}
	return p.Upstream
}

func (p *ProjectEntityMatchResponse) GetSources() []*SourceField {
	if p == nil {
		return nil
	}
	return p.Sources
}

func (p *ProjectEntityMatchResponse) GetAddresses() []*Address {
	if p == nil {
		return nil
	}
	return p.Addresses
}

func (p *ProjectEntityMatchResponse) GetHsCodes() []string {
	if p == nil {
		return nil
	}
	return p.HsCodes
}

func (p *ProjectEntityMatchResponse) GetCreatedAt() string {
	if p == nil {
		return ""
	}
	return p.CreatedAt
}

func (p *ProjectEntityMatchResponse) GetUpdatedAt() *string {
	if p == nil {
		return nil
	}
	return p.UpdatedAt
}

func (p *ProjectEntityMatchResponse) GetMatchProfile() *MatchProfileEnum {
	if p == nil {
		return nil
	}
	return p.MatchProfile
}

func (p *ProjectEntityMatchResponse) GetDeletedAt() *string {
	if p == nil {
		return nil
	}
	return p.DeletedAt
}

func (p *ProjectEntityMatchResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectEntityMatchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectEntityMatchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectEntityMatchResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectEntityMatchResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectEntityResponse struct {
	ProjectEntityId string                        `json:"project_entity_id" url:"project_entity_id"`
	ProjectId       string                        `json:"project_id" url:"project_id"`
	Label           string                        `json:"label" url:"label"`
	UploadIds       []string                      `json:"upload_ids,omitempty" url:"upload_ids,omitempty"`
	Strength        MatchStrengthEnum             `json:"strength" url:"strength"`
	CreatedAt       string                        `json:"created_at" url:"created_at"`
	Attributes      map[string]*AttributeValues   `json:"attributes,omitempty" url:"attributes,omitempty"`
	Countries       []string                      `json:"countries,omitempty" url:"countries,omitempty"`
	RiskCategories  []*ProjectRiskCategory        `json:"risk_categories,omitempty" url:"risk_categories,omitempty"`
	RiskFactors     []*ProjectRiskFactor          `json:"risk_factors,omitempty" url:"risk_factors,omitempty"`
	Upstream        *UpstreamInfo                 `json:"upstream,omitempty" url:"upstream,omitempty"`
	Tags            []*TagResponse                `json:"tags,omitempty" url:"tags,omitempty"`
	Case            *CaseInfo                     `json:"case,omitempty" url:"case,omitempty"`
	Matches         []*ProjectEntityMatchResponse `json:"matches,omitempty" url:"matches,omitempty"`
	UpdatedAt       *string                       `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectEntityResponse) GetProjectEntityId() string {
	if p == nil {
		return ""
	}
	return p.ProjectEntityId
}

func (p *ProjectEntityResponse) GetProjectId() string {
	if p == nil {
		return ""
	}
	return p.ProjectId
}

func (p *ProjectEntityResponse) GetLabel() string {
	if p == nil {
		return ""
	}
	return p.Label
}

func (p *ProjectEntityResponse) GetUploadIds() []string {
	if p == nil {
		return nil
	}
	return p.UploadIds
}

func (p *ProjectEntityResponse) GetStrength() MatchStrengthEnum {
	if p == nil {
		return ""
	}
	return p.Strength
}

func (p *ProjectEntityResponse) GetCreatedAt() string {
	if p == nil {
		return ""
	}
	return p.CreatedAt
}

func (p *ProjectEntityResponse) GetAttributes() map[string]*AttributeValues {
	if p == nil {
		return nil
	}
	return p.Attributes
}

func (p *ProjectEntityResponse) GetCountries() []string {
	if p == nil {
		return nil
	}
	return p.Countries
}

func (p *ProjectEntityResponse) GetRiskCategories() []*ProjectRiskCategory {
	if p == nil {
		return nil
	}
	return p.RiskCategories
}

func (p *ProjectEntityResponse) GetRiskFactors() []*ProjectRiskFactor {
	if p == nil {
		return nil
	}
	return p.RiskFactors
}

func (p *ProjectEntityResponse) GetUpstream() *UpstreamInfo {
	if p == nil {
		return nil
	}
	return p.Upstream
}

func (p *ProjectEntityResponse) GetTags() []*TagResponse {
	if p == nil {
		return nil
	}
	return p.Tags
}

func (p *ProjectEntityResponse) GetCase() *CaseInfo {
	if p == nil {
		return nil
	}
	return p.Case
}

func (p *ProjectEntityResponse) GetMatches() []*ProjectEntityMatchResponse {
	if p == nil {
		return nil
	}
	return p.Matches
}

func (p *ProjectEntityResponse) GetUpdatedAt() *string {
	if p == nil {
		return nil
	}
	return p.UpdatedAt
}

func (p *ProjectEntityResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectEntityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectEntityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectEntityResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectEntityResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectEntitySupplyChainSummaryResponse struct {
	Filters *TradeTraversalFilters                       `json:"filters,omitempty" url:"filters,omitempty"`
	Data    *ProjectEntitySupplyChainSummaryResponseData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectEntitySupplyChainSummaryResponse) GetFilters() *TradeTraversalFilters {
	if p == nil {
		return nil
	}
	return p.Filters
}

func (p *ProjectEntitySupplyChainSummaryResponse) GetData() *ProjectEntitySupplyChainSummaryResponseData {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *ProjectEntitySupplyChainSummaryResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectEntitySupplyChainSummaryResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectEntitySupplyChainSummaryResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectEntitySupplyChainSummaryResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectEntitySupplyChainSummaryResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectEntitySupplyChainSummaryResponseData struct {
	ProjectId       string                            `json:"project_id" url:"project_id"`
	ProjectEntityId string                            `json:"project_entity_id" url:"project_entity_id"`
	Upstream        *ProjectEntitySupplyChainUpstream `json:"upstream,omitempty" url:"upstream,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectEntitySupplyChainSummaryResponseData) GetProjectId() string {
	if p == nil {
		return ""
	}
	return p.ProjectId
}

func (p *ProjectEntitySupplyChainSummaryResponseData) GetProjectEntityId() string {
	if p == nil {
		return ""
	}
	return p.ProjectEntityId
}

func (p *ProjectEntitySupplyChainSummaryResponseData) GetUpstream() *ProjectEntitySupplyChainUpstream {
	if p == nil {
		return nil
	}
	return p.Upstream
}

func (p *ProjectEntitySupplyChainSummaryResponseData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectEntitySupplyChainSummaryResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectEntitySupplyChainSummaryResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectEntitySupplyChainSummaryResponseData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectEntitySupplyChainSummaryResponseData) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectEntitySupplyChainUpstream struct {
	Components     []string                 `json:"components,omitempty" url:"components,omitempty"`
	Countries      []Country                `json:"countries,omitempty" url:"countries,omitempty"`
	RiskCategories []*RiskCategoriesSummary `json:"risk_categories,omitempty" url:"risk_categories,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectEntitySupplyChainUpstream) GetComponents() []string {
	if p == nil {
		return nil
	}
	return p.Components
}

func (p *ProjectEntitySupplyChainUpstream) GetCountries() []Country {
	if p == nil {
		return nil
	}
	return p.Countries
}

func (p *ProjectEntitySupplyChainUpstream) GetRiskCategories() []*RiskCategoriesSummary {
	if p == nil {
		return nil
	}
	return p.RiskCategories
}

func (p *ProjectEntitySupplyChainUpstream) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectEntitySupplyChainUpstream) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectEntitySupplyChainUpstream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectEntitySupplyChainUpstream(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectEntitySupplyChainUpstream) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectRiskCategory struct {
	Id          string   `json:"id" url:"id"`
	Label       string   `json:"label" url:"label"`
	RiskFactors []string `json:"risk_factors,omitempty" url:"risk_factors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectRiskCategory) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *ProjectRiskCategory) GetLabel() string {
	if p == nil {
		return ""
	}
	return p.Label
}

func (p *ProjectRiskCategory) GetRiskFactors() []string {
	if p == nil {
		return nil
	}
	return p.RiskFactors
}

func (p *ProjectRiskCategory) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectRiskCategory) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectRiskCategory
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectRiskCategory(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectRiskCategory) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectRiskFactor struct {
	Id string `json:"id" url:"id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectRiskFactor) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *ProjectRiskFactor) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectRiskFactor) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectRiskFactor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectRiskFactor(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectRiskFactor) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ResolutionAttributes struct {
	Identifier      []*StringOrNumber `json:"identifier,omitempty" url:"identifier,omitempty"`
	Name            []string          `json:"name,omitempty" url:"name,omitempty"`
	Country         []string          `json:"country,omitempty" url:"country,omitempty"`
	Address         []string          `json:"address,omitempty" url:"address,omitempty"`
	DateOfBirth     []string          `json:"date_of_birth,omitempty" url:"date_of_birth,omitempty"`
	Contact         []*StringOrNumber `json:"contact,omitempty" url:"contact,omitempty"`
	Type            []string          `json:"type,omitempty" url:"type,omitempty"`
	City            []string          `json:"city,omitempty" url:"city,omitempty"`
	State           []string          `json:"state,omitempty" url:"state,omitempty"`
	CustomFieldName *CustomFieldValue `json:"custom_{field name},omitempty" url:"custom_{field name},omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResolutionAttributes) GetIdentifier() []*StringOrNumber {
	if r == nil {
		return nil
	}
	return r.Identifier
}

func (r *ResolutionAttributes) GetName() []string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *ResolutionAttributes) GetCountry() []string {
	if r == nil {
		return nil
	}
	return r.Country
}

func (r *ResolutionAttributes) GetAddress() []string {
	if r == nil {
		return nil
	}
	return r.Address
}

func (r *ResolutionAttributes) GetDateOfBirth() []string {
	if r == nil {
		return nil
	}
	return r.DateOfBirth
}

func (r *ResolutionAttributes) GetContact() []*StringOrNumber {
	if r == nil {
		return nil
	}
	return r.Contact
}

func (r *ResolutionAttributes) GetType() []string {
	if r == nil {
		return nil
	}
	return r.Type
}

func (r *ResolutionAttributes) GetCity() []string {
	if r == nil {
		return nil
	}
	return r.City
}

func (r *ResolutionAttributes) GetState() []string {
	if r == nil {
		return nil
	}
	return r.State
}

func (r *ResolutionAttributes) GetCustomFieldName() *CustomFieldValue {
	if r == nil {
		return nil
	}
	return r.CustomFieldName
}

func (r *ResolutionAttributes) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResolutionAttributes) UnmarshalJSON(data []byte) error {
	type unmarshaler ResolutionAttributes
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResolutionAttributes(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResolutionAttributes) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolutionProfile string

const (
	ResolutionProfileSuppliers ResolutionProfile = "suppliers"
	ResolutionProfileCorporate ResolutionProfile = "corporate"
	ResolutionProfileSearch    ResolutionProfile = "search"
	ResolutionProfileScreen    ResolutionProfile = "screen"
)

func NewResolutionProfileFromString(s string) (ResolutionProfile, error) {
	switch s {
	case "suppliers":
		return ResolutionProfileSuppliers, nil
	case "corporate":
		return ResolutionProfileCorporate, nil
	case "search":
		return ResolutionProfileSearch, nil
	case "screen":
		return ResolutionProfileScreen, nil
	}
	var t ResolutionProfile
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResolutionProfile) Ptr() *ResolutionProfile {
	return &r
}

type RiskCategoriesSummary struct {
	Id          string `json:"id" url:"id"`
	Label       string `json:"label" url:"label"`
	RiskFactors []Risk `json:"risk_factors,omitempty" url:"risk_factors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RiskCategoriesSummary) GetId() string {
	if r == nil {
		return ""
	}
	return r.Id
}

func (r *RiskCategoriesSummary) GetLabel() string {
	if r == nil {
		return ""
	}
	return r.Label
}

func (r *RiskCategoriesSummary) GetRiskFactors() []Risk {
	if r == nil {
		return nil
	}
	return r.RiskFactors
}

func (r *RiskCategoriesSummary) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RiskCategoriesSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler RiskCategoriesSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RiskCategoriesSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RiskCategoriesSummary) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SaveProjectEntityBody struct {
	EntityIds  []string              `json:"entity_ids,omitempty" url:"entity_ids,omitempty"`
	Attributes *ResolutionAttributes `json:"attributes,omitempty" url:"attributes,omitempty"`
	Profile    ResolutionProfile     `json:"profile" url:"profile"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SaveProjectEntityBody) GetEntityIds() []string {
	if s == nil {
		return nil
	}
	return s.EntityIds
}

func (s *SaveProjectEntityBody) GetAttributes() *ResolutionAttributes {
	if s == nil {
		return nil
	}
	return s.Attributes
}

func (s *SaveProjectEntityBody) GetProfile() ResolutionProfile {
	if s == nil {
		return ""
	}
	return s.Profile
}

func (s *SaveProjectEntityBody) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SaveProjectEntityBody) UnmarshalJSON(data []byte) error {
	type unmarshaler SaveProjectEntityBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SaveProjectEntityBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SaveProjectEntityBody) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleProjectEntityResponse struct {
	Data *ProjectEntityResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SingleProjectEntityResponse) GetData() *ProjectEntityResponse {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *SingleProjectEntityResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleProjectEntityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleProjectEntityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleProjectEntityResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleProjectEntityResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SourceField struct {
	Id    string `json:"id" url:"id"`
	Label string `json:"label" url:"label"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SourceField) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SourceField) GetLabel() string {
	if s == nil {
		return ""
	}
	return s.Label
}

func (s *SourceField) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SourceField) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceField) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SpecialFacetBucket struct {
	Key      string           `json:"key" url:"key"`
	DocCount int              `json:"doc_count" url:"doc_count"`
	Products []*ProductBucket `json:"products,omitempty" url:"products,omitempty"`
	Lat      *float64         `json:"lat,omitempty" url:"lat,omitempty"`
	Lon      *float64         `json:"lon,omitempty" url:"lon,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SpecialFacetBucket) GetKey() string {
	if s == nil {
		return ""
	}
	return s.Key
}

func (s *SpecialFacetBucket) GetDocCount() int {
	if s == nil {
		return 0
	}
	return s.DocCount
}

func (s *SpecialFacetBucket) GetProducts() []*ProductBucket {
	if s == nil {
		return nil
	}
	return s.Products
}

func (s *SpecialFacetBucket) GetLat() *float64 {
	if s == nil {
		return nil
	}
	return s.Lat
}

func (s *SpecialFacetBucket) GetLon() *float64 {
	if s == nil {
		return nil
	}
	return s.Lon
}

func (s *SpecialFacetBucket) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SpecialFacetBucket) UnmarshalJSON(data []byte) error {
	type unmarshaler SpecialFacetBucket
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SpecialFacetBucket(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SpecialFacetBucket) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SpecialFacetsResponse struct {
	Data map[string][]*SpecialFacetBucket `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SpecialFacetsResponse) GetData() map[string][]*SpecialFacetBucket {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *SpecialFacetsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SpecialFacetsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SpecialFacetsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SpecialFacetsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SpecialFacetsResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StringOrNumber struct {
	String  string
	Integer int
	Double  float64

	typ string
}

func NewStringOrNumberFromString(value string) *StringOrNumber {
	return &StringOrNumber{typ: "String", String: value}
}

func NewStringOrNumberFromInteger(value int) *StringOrNumber {
	return &StringOrNumber{typ: "Integer", Integer: value}
}

func NewStringOrNumberFromDouble(value float64) *StringOrNumber {
	return &StringOrNumber{typ: "Double", Double: value}
}

func (s *StringOrNumber) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *StringOrNumber) GetInteger() int {
	if s == nil {
		return 0
	}
	return s.Integer
}

func (s *StringOrNumber) GetDouble() float64 {
	if s == nil {
		return 0
	}
	return s.Double
}

func (s *StringOrNumber) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		s.typ = "Integer"
		s.Integer = valueInteger
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		s.typ = "Double"
		s.Double = valueDouble
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s StringOrNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Integer" || s.Integer != 0 {
		return json.Marshal(s.Integer)
	}
	if s.typ == "Double" || s.Double != 0 {
		return json.Marshal(s.Double)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type StringOrNumberVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
	VisitDouble(float64) error
}

func (s *StringOrNumber) Accept(visitor StringOrNumberVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Integer" || s.Integer != 0 {
		return visitor.VisitInteger(s.Integer)
	}
	if s.typ == "Double" || s.Double != 0 {
		return visitor.VisitDouble(s.Double)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type TagResponse struct {
	Id        string  `json:"id" url:"id"`
	Label     string  `json:"label" url:"label"`
	CreatedAt string  `json:"created_at" url:"created_at"`
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TagResponse) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TagResponse) GetLabel() string {
	if t == nil {
		return ""
	}
	return t.Label
}

func (t *TagResponse) GetCreatedAt() string {
	if t == nil {
		return ""
	}
	return t.CreatedAt
}

func (t *TagResponse) GetUpdatedAt() *string {
	if t == nil {
		return nil
	}
	return t.UpdatedAt
}

func (t *TagResponse) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TagResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler TagResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TagResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TagResponse) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TradeCounts struct {
	ReceiverOf int `json:"receiver_of" url:"receiver_of"`
	ShipperOf  int `json:"shipper_of" url:"shipper_of"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TradeCounts) GetReceiverOf() int {
	if t == nil {
		return 0
	}
	return t.ReceiverOf
}

func (t *TradeCounts) GetShipperOf() int {
	if t == nil {
		return 0
	}
	return t.ShipperOf
}

func (t *TradeCounts) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TradeCounts) UnmarshalJSON(data []byte) error {
	type unmarshaler TradeCounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TradeCounts(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TradeCounts) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Translation struct {
	Target string  `json:"target" url:"target"`
	Source *string `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Translation) GetTarget() string {
	if t == nil {
		return ""
	}
	return t.Target
}

func (t *Translation) GetSource() *string {
	if t == nil {
		return nil
	}
	return t.Source
}

func (t *Translation) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Translation) UnmarshalJSON(data []byte) error {
	type unmarshaler Translation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Translation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Translation) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type UpdateEntityTagsResponse struct {
	Data []string `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateEntityTagsResponse) GetData() []string {
	if u == nil {
		return nil
	}
	return u.Data
}

func (u *UpdateEntityTagsResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateEntityTagsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateEntityTagsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateEntityTagsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateEntityTagsResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateProjectEntityTagsBody struct {
	Ids []string `json:"ids,omitempty" url:"ids,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateProjectEntityTagsBody) GetIds() []string {
	if u == nil {
		return nil
	}
	return u.Ids
}

func (u *UpdateProjectEntityTagsBody) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateProjectEntityTagsBody) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateProjectEntityTagsBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateProjectEntityTagsBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateProjectEntityTagsBody) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpstreamCount = map[string]map[string][]*ProductCount

type UpstreamInfo struct {
	RiskFactors   []*ProjectRiskFactor `json:"risk_factors,omitempty" url:"risk_factors,omitempty"`
	Countries     []string             `json:"countries,omitempty" url:"countries,omitempty"`
	TradeCounts   *TradeCounts         `json:"trade_counts,omitempty" url:"trade_counts,omitempty"`
	HasUpstream   bool                 `json:"has_upstream" url:"has_upstream"`
	Products      []string             `json:"products,omitempty" url:"products,omitempty"`
	RiskCounts    *UpstreamCount       `json:"risk_counts,omitempty" url:"risk_counts,omitempty"`
	CountryCounts *UpstreamCount       `json:"country_counts,omitempty" url:"country_counts,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpstreamInfo) GetRiskFactors() []*ProjectRiskFactor {
	if u == nil {
		return nil
	}
	return u.RiskFactors
}

func (u *UpstreamInfo) GetCountries() []string {
	if u == nil {
		return nil
	}
	return u.Countries
}

func (u *UpstreamInfo) GetTradeCounts() *TradeCounts {
	if u == nil {
		return nil
	}
	return u.TradeCounts
}

func (u *UpstreamInfo) GetHasUpstream() bool {
	if u == nil {
		return false
	}
	return u.HasUpstream
}

func (u *UpstreamInfo) GetProducts() []string {
	if u == nil {
		return nil
	}
	return u.Products
}

func (u *UpstreamInfo) GetRiskCounts() *UpstreamCount {
	if u == nil {
		return nil
	}
	return u.RiskCounts
}

func (u *UpstreamInfo) GetCountryCounts() *UpstreamCount {
	if u == nil {
		return nil
	}
	return u.CountryCounts
}

func (u *UpstreamInfo) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpstreamInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler UpstreamInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpstreamInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpstreamInfo) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
