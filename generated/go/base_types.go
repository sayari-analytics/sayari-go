// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/sayari-analytics/sayari-go/generated/go/internal"
)

type CountQualifier string

const (
	CountQualifierEq  CountQualifier = "eq"
	CountQualifierGte CountQualifier = "gte"
)

func NewCountQualifierFromString(s string) (CountQualifier, error) {
	switch s {
	case "eq":
		return CountQualifierEq, nil
	case "gte":
		return CountQualifierGte, nil
	}
	var t CountQualifier
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CountQualifier) Ptr() *CountQualifier {
	return &c
}

// Response fields that represent unbounded collections, such as a search result or an entity's attributes or relationships, or a record's references, can all be paginated in cases where the collection is larger than can be efficiently returned in a single request.
type PaginatedResponse struct {
	Limit int             `json:"limit" url:"limit"`
	Size  *QualifiedCount `json:"size,omitempty" url:"size,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedResponse) GetLimit() int {
	if p == nil {
		return 0
	}
	return p.Limit
}

func (p *PaginatedResponse) GetSize() *QualifiedCount {
	if p == nil {
		return nil
	}
	return p.Size
}

func (p *PaginatedResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type QualifiedCount struct {
	Count     int            `json:"count" url:"count"`
	Qualifier CountQualifier `json:"qualifier" url:"qualifier"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QualifiedCount) GetCount() int {
	if q == nil {
		return 0
	}
	return q.Count
}

func (q *QualifiedCount) GetQualifier() CountQualifier {
	if q == nil {
		return ""
	}
	return q.Qualifier
}

func (q *QualifiedCount) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QualifiedCount) UnmarshalJSON(data []byte) error {
	type unmarshaler QualifiedCount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QualifiedCount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QualifiedCount) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}
