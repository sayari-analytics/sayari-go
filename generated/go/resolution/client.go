// This file was auto-generated by Fern from our API Definition.

package resolution

import (
	bytes "bytes"
	context "context"
	json "encoding/json"
	errors "errors"
	fmt "fmt"
	generatedgo "github.com/sayari-analytics/sayari-go/generated/go"
	core "github.com/sayari-analytics/sayari-go/generated/go/core"
	option "github.com/sayari-analytics/sayari-go/generated/go/option"
	io "io"
	http "net/http"
	url "net/url"
)

type Client struct {
	baseURL string
	caller  *core.Caller
	header  http.Header
}

func NewClient(opts ...option.RequestOption) *Client {
	options := core.NewRequestOptions(opts...)
	return &Client{
		baseURL: options.BaseURL,
		caller: core.NewCaller(
			&core.CallerParams{
				Client:      options.HTTPClient,
				MaxAttempts: options.MaxAttempts,
			},
			options.RateLimiter,
		),
		header: options.ToHeader(),
	}
}

// The resolution endpoints allow users to search for matching entities against a provided list of attributes. The endpoint is similar to the search endpoint, except it's tuned to only return the best match so the client doesn't need to do as much or any post-processing work to filter down results.
func (c *Client) Resolution(
	ctx context.Context,
	request *generatedgo.Resolution,
	opts ...option.RequestOption,
) (*generatedgo.ResolutionResponse, error) {
	options := core.NewRequestOptions(opts...)

	baseURL := "https://api.sayari.com"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	if options.BaseURL != "" {
		baseURL = options.BaseURL
	}
	endpointURL := baseURL + "/" + "v1/resolution"

	queryParams := make(url.Values)
	for _, value := range request.Name {
		queryParams.Add("name", fmt.Sprintf("%v", *value))
	}
	for _, value := range request.Identifier {
		queryParams.Add("identifier", fmt.Sprintf("%v", *value))
	}
	for _, value := range request.Country {
		queryParams.Add("country", fmt.Sprintf("%v", *value))
	}
	for _, value := range request.Address {
		queryParams.Add("address", fmt.Sprintf("%v", *value))
	}
	for _, value := range request.DateOfBirth {
		queryParams.Add("date_of_birth", fmt.Sprintf("%v", *value))
	}
	for _, value := range request.Contact {
		queryParams.Add("contact", fmt.Sprintf("%v", *value))
	}
	for _, value := range request.Type {
		queryParams.Add("type", fmt.Sprintf("%v", *value))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	headers := core.MergeHeaders(c.header.Clone(), options.ToHeader())

	errorDecoder := func(statusCode int, body io.Reader) error {
		raw, err := io.ReadAll(body)
		if err != nil {
			return err
		}
		apiError := core.NewAPIError(statusCode, errors.New(string(raw)))
		decoder := json.NewDecoder(bytes.NewReader(raw))
		switch statusCode {
		case 400:
			value := new(generatedgo.BadRequest)
			value.APIError = apiError
			if err := decoder.Decode(value); err != nil {
				return apiError
			}
			return value
		case 401:
			value := new(generatedgo.Unauthorized)
			value.APIError = apiError
			if err := decoder.Decode(value); err != nil {
				return apiError
			}
			return value
		case 405:
			value := new(generatedgo.MethodNotAllowed)
			value.APIError = apiError
			if err := decoder.Decode(value); err != nil {
				return apiError
			}
			return value
		case 406:
			value := new(generatedgo.NotAcceptable)
			value.APIError = apiError
			if err := decoder.Decode(value); err != nil {
				return apiError
			}
			return value
		case 429:
			value := new(generatedgo.RateLimitExceeded)
			value.APIError = apiError
			if err := decoder.Decode(value); err != nil {
				return apiError
			}
			return value
		case 500:
			value := new(generatedgo.InternalServerError)
			value.APIError = apiError
			if err := decoder.Decode(value); err != nil {
				return apiError
			}
			return value
		}
		return apiError
	}

	var response *generatedgo.ResolutionResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:          endpointURL,
			Method:       http.MethodGet,
			MaxAttempts:  options.MaxAttempts,
			Headers:      headers,
			Client:       options.HTTPClient,
			Response:     &response,
			ErrorDecoder: errorDecoder,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}
