// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/sayari-analytics/sayari-go/generated/go/internal"
)

type ClientName string

const (
	ClientNameGo     ClientName = "sayari-go"
	ClientNamePython ClientName = "sayari-python"
	ClientNameJava   ClientName = "sayari-java"
	ClientNameNode   ClientName = "sayari-node"
)

func NewClientNameFromString(s string) (ClientName, error) {
	switch s {
	case "sayari-go":
		return ClientNameGo, nil
	case "sayari-python":
		return ClientNamePython, nil
	case "sayari-java":
		return ClientNameJava, nil
	case "sayari-node":
		return ClientNameNode, nil
	}
	var t ClientName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientName) Ptr() *ClientName {
	return &c
}

// A type of legal entity in a given jurisdiction (e.g. 'LLC,' 'Sociedad Anonima,' 'Private Company Limited by Shares')
type CompanyType = string

type Coordinate struct {
	Lat     float64 `json:"lat" url:"lat"`
	Lng     float64 `json:"lng" url:"lng"`
	Address string  `json:"address" url:"address"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Coordinate) GetLat() float64 {
	if c == nil {
		return 0
	}
	return c.Lat
}

func (c *Coordinate) GetLng() float64 {
	if c == nil {
		return 0
	}
	return c.Lng
}

func (c *Coordinate) GetAddress() string {
	if c == nil {
		return ""
	}
	return c.Address
}

func (c *Coordinate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Coordinate) UnmarshalJSON(data []byte) error {
	type unmarshaler Coordinate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Coordinate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Coordinate) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The attributes fields common to most entities.
type CoreEntity struct {
	Attributes map[Attributes][]interface{} `json:"attributes,omitempty" url:"attributes,omitempty"`
	// Unique identifier of the entity
	Id string `json:"id" url:"id"`
	// User or group that created the entity, if applicable. Undefined for Sayari entities.
	Owner *string `json:"owner,omitempty" url:"owner,omitempty"`
	// The [entity type](/sayari-library/ontology/entities).
	Type Entities `json:"type" url:"type"`
	// Display name of the entity
	Label string `json:"label" url:"label"`
	// Name variations of the entity.
	Names             []string                `json:"names,omitempty" url:"names,omitempty"`
	CompanyType       *CompanyType            `json:"company_type,omitempty" url:"company_type,omitempty"`
	RegistrationDate  *EntityRegistrationDate `json:"registration_date,omitempty" url:"registration_date,omitempty"`
	LatestStatus      *Status                 `json:"latest_status,omitempty" url:"latest_status,omitempty"`
	ShipmentArrival   *ShipmentArrival        `json:"shipment_arrival,omitempty" url:"shipment_arrival,omitempty"`
	ShipmentDeparture *ShipmentDeparture      `json:"shipment_departure,omitempty" url:"shipment_departure,omitempty"`
	HsCode            *EntityHsCode           `json:"hs_code,omitempty" url:"hs_code,omitempty"`
	TranslatedLabel   *EntityTranslatedLabel  `json:"translated_label,omitempty" url:"translated_label,omitempty"`
	Identifiers       []*Identifier           `json:"identifiers,omitempty" url:"identifiers,omitempty"`
	// List of physical addresses associated with the entity. See more [here](/sayari-library/ontology/attributes#address)
	Addresses []string `json:"addresses,omitempty" url:"addresses,omitempty"`
	// Birth date of a person. See more [here](/sayari-library/ontology/attributes#date-of-birth)
	DateOfBirth *string `json:"date_of_birth,omitempty" url:"date_of_birth,omitempty"`
	// Entity [country](/sayari-library/ontology/enumerated-types#country)
	Countries []Country `json:"countries,omitempty" url:"countries,omitempty"`
	// True if the entity existed in the past but not at the present time, otherwise false. Always false for data curation.
	Closed                   *bool             `json:"closed,omitempty" url:"closed,omitempty"`
	RelatedEntitiesCount     int               `json:"related_entities_count" url:"related_entities_count"`
	UserRelatedEntitiesCount int               `json:"user_related_entities_count" url:"user_related_entities_count"`
	RelationshipCounts       RelationshipCount `json:"relationship_counts,omitempty" url:"relationship_counts,omitempty"`
	UserRelationshipCounts   RelationshipCount `json:"user_relationship_counts,omitempty" url:"user_relationship_counts,omitempty"`
	AttributeCounts          interface{}       `json:"attribute_counts,omitempty" url:"attribute_counts,omitempty"`
	UserAttributeCounts      interface{}       `json:"user_attribute_counts,omitempty" url:"user_attribute_counts,omitempty"`
	TradeCount               map[string]int    `json:"trade_count,omitempty" url:"trade_count,omitempty"`
	RecordCount              int               `json:"record_count" url:"record_count"`
	UserRecordCount          int               `json:"user_record_count" url:"user_record_count"`
	// Number of records associated with the entity, grouped by source.
	SourceCounts map[string]*SourceCountInfo `json:"source_counts,omitempty" url:"source_counts,omitempty"`
	Psa          *Psa                        `json:"psa,omitempty" url:"psa,omitempty"`
	// [Risk factors](/sayari-library/ontology/risk-factors) associated with the entity.
	Risk     EntityRisk `json:"risk,omitempty" url:"risk,omitempty"`
	Created  *string    `json:"created,omitempty" url:"created,omitempty"`
	Updated  *string    `json:"updated,omitempty" url:"updated,omitempty"`
	EditedBy *string    `json:"edited_by,omitempty" url:"edited_by,omitempty"`
	Editable *bool      `json:"editable,omitempty" url:"editable,omitempty"`
	Upload   *string    `json:"upload,omitempty" url:"upload,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CoreEntity) GetAttributes() map[Attributes][]interface{} {
	if c == nil {
		return nil
	}
	return c.Attributes
}

func (c *CoreEntity) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *CoreEntity) GetOwner() *string {
	if c == nil {
		return nil
	}
	return c.Owner
}

func (c *CoreEntity) GetType() Entities {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *CoreEntity) GetLabel() string {
	if c == nil {
		return ""
	}
	return c.Label
}

func (c *CoreEntity) GetNames() []string {
	if c == nil {
		return nil
	}
	return c.Names
}

func (c *CoreEntity) GetCompanyType() *CompanyType {
	if c == nil {
		return nil
	}
	return c.CompanyType
}

func (c *CoreEntity) GetRegistrationDate() *EntityRegistrationDate {
	if c == nil {
		return nil
	}
	return c.RegistrationDate
}

func (c *CoreEntity) GetLatestStatus() *Status {
	if c == nil {
		return nil
	}
	return c.LatestStatus
}

func (c *CoreEntity) GetShipmentArrival() *ShipmentArrival {
	if c == nil {
		return nil
	}
	return c.ShipmentArrival
}

func (c *CoreEntity) GetShipmentDeparture() *ShipmentDeparture {
	if c == nil {
		return nil
	}
	return c.ShipmentDeparture
}

func (c *CoreEntity) GetHsCode() *EntityHsCode {
	if c == nil {
		return nil
	}
	return c.HsCode
}

func (c *CoreEntity) GetTranslatedLabel() *EntityTranslatedLabel {
	if c == nil {
		return nil
	}
	return c.TranslatedLabel
}

func (c *CoreEntity) GetIdentifiers() []*Identifier {
	if c == nil {
		return nil
	}
	return c.Identifiers
}

func (c *CoreEntity) GetAddresses() []string {
	if c == nil {
		return nil
	}
	return c.Addresses
}

func (c *CoreEntity) GetDateOfBirth() *string {
	if c == nil {
		return nil
	}
	return c.DateOfBirth
}

func (c *CoreEntity) GetCountries() []Country {
	if c == nil {
		return nil
	}
	return c.Countries
}

func (c *CoreEntity) GetClosed() *bool {
	if c == nil {
		return nil
	}
	return c.Closed
}

func (c *CoreEntity) GetRelatedEntitiesCount() int {
	if c == nil {
		return 0
	}
	return c.RelatedEntitiesCount
}

func (c *CoreEntity) GetUserRelatedEntitiesCount() int {
	if c == nil {
		return 0
	}
	return c.UserRelatedEntitiesCount
}

func (c *CoreEntity) GetRelationshipCounts() RelationshipCount {
	if c == nil {
		return nil
	}
	return c.RelationshipCounts
}

func (c *CoreEntity) GetUserRelationshipCounts() RelationshipCount {
	if c == nil {
		return nil
	}
	return c.UserRelationshipCounts
}

func (c *CoreEntity) GetAttributeCounts() interface{} {
	if c == nil {
		return nil
	}
	return c.AttributeCounts
}

func (c *CoreEntity) GetUserAttributeCounts() interface{} {
	if c == nil {
		return nil
	}
	return c.UserAttributeCounts
}

func (c *CoreEntity) GetTradeCount() map[string]int {
	if c == nil {
		return nil
	}
	return c.TradeCount
}

func (c *CoreEntity) GetRecordCount() int {
	if c == nil {
		return 0
	}
	return c.RecordCount
}

func (c *CoreEntity) GetUserRecordCount() int {
	if c == nil {
		return 0
	}
	return c.UserRecordCount
}

func (c *CoreEntity) GetSourceCounts() map[string]*SourceCountInfo {
	if c == nil {
		return nil
	}
	return c.SourceCounts
}

func (c *CoreEntity) GetPsa() *Psa {
	if c == nil {
		return nil
	}
	return c.Psa
}

func (c *CoreEntity) GetRisk() EntityRisk {
	if c == nil {
		return nil
	}
	return c.Risk
}

func (c *CoreEntity) GetCreated() *string {
	if c == nil {
		return nil
	}
	return c.Created
}

func (c *CoreEntity) GetUpdated() *string {
	if c == nil {
		return nil
	}
	return c.Updated
}

func (c *CoreEntity) GetEditedBy() *string {
	if c == nil {
		return nil
	}
	return c.EditedBy
}

func (c *CoreEntity) GetEditable() *bool {
	if c == nil {
		return nil
	}
	return c.Editable
}

func (c *CoreEntity) GetUpload() *string {
	if c == nil {
		return nil
	}
	return c.Upload
}

func (c *CoreEntity) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CoreEntity) UnmarshalJSON(data []byte) error {
	type unmarshaler CoreEntity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CoreEntity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CoreEntity) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Fields of an entity when nested within other data structures.
type EmbeddedEntity struct {
	// Unique identifier of the entity
	Id string `json:"id" url:"id"`
	// Display name of the entity
	Label string `json:"label" url:"label"`
	// Number of outgoing relationships
	Degree int `json:"degree" url:"degree"`
	// True if the entity existed in the past but not at the present time, otherwise false. Always false for data curation.
	Closed bool `json:"closed" url:"closed"`
	// Convenience URL to the entity in the API.
	EntityUrl string `json:"entity_url" url:"entity_url"`
	// True if the entity has the ["Politically Exposed Person (PEP)" risk factor](/sayari-library/ontology/risk-factors#politically-exposed-person-pep-), otherwise false.
	Pep   bool    `json:"pep" url:"pep"`
	PsaId *string `json:"psa_id,omitempty" url:"psa_id,omitempty"`
	// Number of entities that are Possibly the Same As (PSA) the entity.
	PsaCount int `json:"psa_count" url:"psa_count"`
	// True if the entity has the ["Sanctioned" risk factor](/sayari-library/ontology/risk-factors#sanctioned), otherwise false.
	Sanctioned bool `json:"sanctioned" url:"sanctioned"`
	// The [entity type](/sayari-library/ontology/entities).
	Type        Entities      `json:"type" url:"type"`
	Identifiers []*Identifier `json:"identifiers,omitempty" url:"identifiers,omitempty"`
	// Entity [country](/sayari-library/ontology/enumerated-types#country)
	Countries []Country `json:"countries,omitempty" url:"countries,omitempty"`
	// Number of records associated with the entity, grouped by source.
	SourceCount map[string]*SourceCountInfo `json:"source_count,omitempty" url:"source_count,omitempty"`
	// List of physical addresses associated with the entity. See more [here](/sayari-library/ontology/attributes#address)
	Addresses  []string       `json:"addresses,omitempty" url:"addresses,omitempty"`
	TradeCount map[string]int `json:"trade_count,omitempty" url:"trade_count,omitempty"`
	// Birth date of a person. See more [here](/sayari-library/ontology/attributes#date-of-birth)
	DateOfBirth           *string           `json:"date_of_birth,omitempty" url:"date_of_birth,omitempty"`
	RelationshipCount     RelationshipCount `json:"relationship_count,omitempty" url:"relationship_count,omitempty"`
	UserRelationshipCount RelationshipCount `json:"user_relationship_count,omitempty" url:"user_relationship_count,omitempty"`
	// Count of attributes for a given [attribute type](/sayari-library/ontology/attributes)
	AttributeCount map[Attributes]int `json:"attribute_count,omitempty" url:"attribute_count,omitempty"`
	// Count of user-created attributes for a given [attribute type](/sayari-library/ontology/attributes)
	UserAttributeCount map[Attributes]int `json:"user_attribute_count,omitempty" url:"user_attribute_count,omitempty"`
	// Count of attributes for a given [attribute type](/sayari-library/ontology/attributes)
	AttributeCounts map[Attributes]int `json:"attribute_counts,omitempty" url:"attribute_counts,omitempty"`
	// Count of user-created attributes for a given [attribute type](/sayari-library/ontology/attributes)
	UserAttributeCounts      map[Attributes]int `json:"user_attribute_counts,omitempty" url:"user_attribute_counts,omitempty"`
	RelatedEntitiesCount     int                `json:"related_entities_count" url:"related_entities_count"`
	UserRelatedEntitiesCount int                `json:"user_related_entities_count" url:"user_related_entities_count"`
	UserRecordCount          int                `json:"user_record_count" url:"user_record_count"`
	ReferenceId              *string            `json:"reference_id,omitempty" url:"reference_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmbeddedEntity) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *EmbeddedEntity) GetLabel() string {
	if e == nil {
		return ""
	}
	return e.Label
}

func (e *EmbeddedEntity) GetDegree() int {
	if e == nil {
		return 0
	}
	return e.Degree
}

func (e *EmbeddedEntity) GetClosed() bool {
	if e == nil {
		return false
	}
	return e.Closed
}

func (e *EmbeddedEntity) GetEntityUrl() string {
	if e == nil {
		return ""
	}
	return e.EntityUrl
}

func (e *EmbeddedEntity) GetPep() bool {
	if e == nil {
		return false
	}
	return e.Pep
}

func (e *EmbeddedEntity) GetPsaId() *string {
	if e == nil {
		return nil
	}
	return e.PsaId
}

func (e *EmbeddedEntity) GetPsaCount() int {
	if e == nil {
		return 0
	}
	return e.PsaCount
}

func (e *EmbeddedEntity) GetSanctioned() bool {
	if e == nil {
		return false
	}
	return e.Sanctioned
}

func (e *EmbeddedEntity) GetType() Entities {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EmbeddedEntity) GetIdentifiers() []*Identifier {
	if e == nil {
		return nil
	}
	return e.Identifiers
}

func (e *EmbeddedEntity) GetCountries() []Country {
	if e == nil {
		return nil
	}
	return e.Countries
}

func (e *EmbeddedEntity) GetSourceCount() map[string]*SourceCountInfo {
	if e == nil {
		return nil
	}
	return e.SourceCount
}

func (e *EmbeddedEntity) GetAddresses() []string {
	if e == nil {
		return nil
	}
	return e.Addresses
}

func (e *EmbeddedEntity) GetTradeCount() map[string]int {
	if e == nil {
		return nil
	}
	return e.TradeCount
}

func (e *EmbeddedEntity) GetDateOfBirth() *string {
	if e == nil {
		return nil
	}
	return e.DateOfBirth
}

func (e *EmbeddedEntity) GetRelationshipCount() RelationshipCount {
	if e == nil {
		return nil
	}
	return e.RelationshipCount
}

func (e *EmbeddedEntity) GetUserRelationshipCount() RelationshipCount {
	if e == nil {
		return nil
	}
	return e.UserRelationshipCount
}

func (e *EmbeddedEntity) GetAttributeCount() map[Attributes]int {
	if e == nil {
		return nil
	}
	return e.AttributeCount
}

func (e *EmbeddedEntity) GetUserAttributeCount() map[Attributes]int {
	if e == nil {
		return nil
	}
	return e.UserAttributeCount
}

func (e *EmbeddedEntity) GetAttributeCounts() map[Attributes]int {
	if e == nil {
		return nil
	}
	return e.AttributeCounts
}

func (e *EmbeddedEntity) GetUserAttributeCounts() map[Attributes]int {
	if e == nil {
		return nil
	}
	return e.UserAttributeCounts
}

func (e *EmbeddedEntity) GetRelatedEntitiesCount() int {
	if e == nil {
		return 0
	}
	return e.RelatedEntitiesCount
}

func (e *EmbeddedEntity) GetUserRelatedEntitiesCount() int {
	if e == nil {
		return 0
	}
	return e.UserRelatedEntitiesCount
}

func (e *EmbeddedEntity) GetUserRecordCount() int {
	if e == nil {
		return 0
	}
	return e.UserRecordCount
}

func (e *EmbeddedEntity) GetReferenceId() *string {
	if e == nil {
		return nil
	}
	return e.ReferenceId
}

func (e *EmbeddedEntity) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmbeddedEntity) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbeddedEntity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbeddedEntity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbeddedEntity) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Additional fields providing more details about an entity
type EntityDetails struct {
	// Unique identifier of the entity
	Id string `json:"id" url:"id"`
	// Display name of the entity
	Label string `json:"label" url:"label"`
	// Number of outgoing relationships
	Degree int `json:"degree" url:"degree"`
	// True if the entity existed in the past but not at the present time, otherwise false. Always false for data curation.
	Closed bool `json:"closed" url:"closed"`
	// Convenience URL to the entity in the API.
	EntityUrl string `json:"entity_url" url:"entity_url"`
	// True if the entity has the ["Politically Exposed Person (PEP)" risk factor](/sayari-library/ontology/risk-factors#politically-exposed-person-pep-), otherwise false.
	Pep   bool    `json:"pep" url:"pep"`
	PsaId *string `json:"psa_id,omitempty" url:"psa_id,omitempty"`
	// Number of entities that are Possibly the Same As (PSA) the entity.
	PsaCount int `json:"psa_count" url:"psa_count"`
	// True if the entity has the ["Sanctioned" risk factor](/sayari-library/ontology/risk-factors#sanctioned), otherwise false.
	Sanctioned bool `json:"sanctioned" url:"sanctioned"`
	// The [entity type](/sayari-library/ontology/entities).
	Type        Entities      `json:"type" url:"type"`
	Identifiers []*Identifier `json:"identifiers,omitempty" url:"identifiers,omitempty"`
	// Entity [country](/sayari-library/ontology/enumerated-types#country)
	Countries []Country `json:"countries,omitempty" url:"countries,omitempty"`
	// Number of records associated with the entity, grouped by source.
	SourceCount map[string]*SourceCountInfo `json:"source_count,omitempty" url:"source_count,omitempty"`
	// List of physical addresses associated with the entity. See more [here](/sayari-library/ontology/attributes#address)
	Addresses  []string       `json:"addresses,omitempty" url:"addresses,omitempty"`
	TradeCount map[string]int `json:"trade_count,omitempty" url:"trade_count,omitempty"`
	// Birth date of a person. See more [here](/sayari-library/ontology/attributes#date-of-birth)
	DateOfBirth           *string           `json:"date_of_birth,omitempty" url:"date_of_birth,omitempty"`
	RelationshipCount     RelationshipCount `json:"relationship_count,omitempty" url:"relationship_count,omitempty"`
	UserRelationshipCount RelationshipCount `json:"user_relationship_count,omitempty" url:"user_relationship_count,omitempty"`
	// Count of attributes for a given [attribute type](/sayari-library/ontology/attributes)
	AttributeCount map[Attributes]int `json:"attribute_count,omitempty" url:"attribute_count,omitempty"`
	// Count of user-created attributes for a given [attribute type](/sayari-library/ontology/attributes)
	UserAttributeCount map[Attributes]int `json:"user_attribute_count,omitempty" url:"user_attribute_count,omitempty"`
	// Count of attributes for a given [attribute type](/sayari-library/ontology/attributes)
	AttributeCounts map[Attributes]int `json:"attribute_counts,omitempty" url:"attribute_counts,omitempty"`
	// Count of user-created attributes for a given [attribute type](/sayari-library/ontology/attributes)
	UserAttributeCounts      map[Attributes]int      `json:"user_attribute_counts,omitempty" url:"user_attribute_counts,omitempty"`
	RelatedEntitiesCount     int                     `json:"related_entities_count" url:"related_entities_count"`
	UserRelatedEntitiesCount int                     `json:"user_related_entities_count" url:"user_related_entities_count"`
	UserRecordCount          int                     `json:"user_record_count" url:"user_record_count"`
	ReferenceId              *string                 `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	RegistrationDate         *EntityRegistrationDate `json:"registration_date,omitempty" url:"registration_date,omitempty"`
	TranslatedLabel          *EntityTranslatedLabel  `json:"translated_label,omitempty" url:"translated_label,omitempty"`
	HsCode                   *EntityHsCode           `json:"hs_code,omitempty" url:"hs_code,omitempty"`
	ShipmentArrival          *ShipmentArrival        `json:"shipment_arrival,omitempty" url:"shipment_arrival,omitempty"`
	ShipmentDeparture        *ShipmentDeparture      `json:"shipment_departure,omitempty" url:"shipment_departure,omitempty"`
	CompanyType              *CompanyType            `json:"company_type,omitempty" url:"company_type,omitempty"`
	LatestStatus             *Status                 `json:"latest_status,omitempty" url:"latest_status,omitempty"`
	// [Risk factors](/sayari-library/ontology/risk-factors) associated with the entity.
	Risk EntityRisk `json:"risk,omitempty" url:"risk,omitempty"`
	// Detailed information about the entity's [attributes](/sayari-library/ontology/attributes).
	Attributes *AttributeDetails `json:"attributes,omitempty" url:"attributes,omitempty"`
	// Detailed information about the entity's [relationships](/sayari-library/ontology/relationships).
	Relationships  *EntityRelationships `json:"relationships,omitempty" url:"relationships,omitempty"`
	PossiblySameAs *PossiblySameAs      `json:"possibly_same_as,omitempty" url:"possibly_same_as,omitempty"`
	ReferencedBy   *ReferencedBy        `json:"referenced_by,omitempty" url:"referenced_by,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityDetails) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *EntityDetails) GetLabel() string {
	if e == nil {
		return ""
	}
	return e.Label
}

func (e *EntityDetails) GetDegree() int {
	if e == nil {
		return 0
	}
	return e.Degree
}

func (e *EntityDetails) GetClosed() bool {
	if e == nil {
		return false
	}
	return e.Closed
}

func (e *EntityDetails) GetEntityUrl() string {
	if e == nil {
		return ""
	}
	return e.EntityUrl
}

func (e *EntityDetails) GetPep() bool {
	if e == nil {
		return false
	}
	return e.Pep
}

func (e *EntityDetails) GetPsaId() *string {
	if e == nil {
		return nil
	}
	return e.PsaId
}

func (e *EntityDetails) GetPsaCount() int {
	if e == nil {
		return 0
	}
	return e.PsaCount
}

func (e *EntityDetails) GetSanctioned() bool {
	if e == nil {
		return false
	}
	return e.Sanctioned
}

func (e *EntityDetails) GetType() Entities {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EntityDetails) GetIdentifiers() []*Identifier {
	if e == nil {
		return nil
	}
	return e.Identifiers
}

func (e *EntityDetails) GetCountries() []Country {
	if e == nil {
		return nil
	}
	return e.Countries
}

func (e *EntityDetails) GetSourceCount() map[string]*SourceCountInfo {
	if e == nil {
		return nil
	}
	return e.SourceCount
}

func (e *EntityDetails) GetAddresses() []string {
	if e == nil {
		return nil
	}
	return e.Addresses
}

func (e *EntityDetails) GetTradeCount() map[string]int {
	if e == nil {
		return nil
	}
	return e.TradeCount
}

func (e *EntityDetails) GetDateOfBirth() *string {
	if e == nil {
		return nil
	}
	return e.DateOfBirth
}

func (e *EntityDetails) GetRelationshipCount() RelationshipCount {
	if e == nil {
		return nil
	}
	return e.RelationshipCount
}

func (e *EntityDetails) GetUserRelationshipCount() RelationshipCount {
	if e == nil {
		return nil
	}
	return e.UserRelationshipCount
}

func (e *EntityDetails) GetAttributeCount() map[Attributes]int {
	if e == nil {
		return nil
	}
	return e.AttributeCount
}

func (e *EntityDetails) GetUserAttributeCount() map[Attributes]int {
	if e == nil {
		return nil
	}
	return e.UserAttributeCount
}

func (e *EntityDetails) GetAttributeCounts() map[Attributes]int {
	if e == nil {
		return nil
	}
	return e.AttributeCounts
}

func (e *EntityDetails) GetUserAttributeCounts() map[Attributes]int {
	if e == nil {
		return nil
	}
	return e.UserAttributeCounts
}

func (e *EntityDetails) GetRelatedEntitiesCount() int {
	if e == nil {
		return 0
	}
	return e.RelatedEntitiesCount
}

func (e *EntityDetails) GetUserRelatedEntitiesCount() int {
	if e == nil {
		return 0
	}
	return e.UserRelatedEntitiesCount
}

func (e *EntityDetails) GetUserRecordCount() int {
	if e == nil {
		return 0
	}
	return e.UserRecordCount
}

func (e *EntityDetails) GetReferenceId() *string {
	if e == nil {
		return nil
	}
	return e.ReferenceId
}

func (e *EntityDetails) GetRegistrationDate() *EntityRegistrationDate {
	if e == nil {
		return nil
	}
	return e.RegistrationDate
}

func (e *EntityDetails) GetTranslatedLabel() *EntityTranslatedLabel {
	if e == nil {
		return nil
	}
	return e.TranslatedLabel
}

func (e *EntityDetails) GetHsCode() *EntityHsCode {
	if e == nil {
		return nil
	}
	return e.HsCode
}

func (e *EntityDetails) GetShipmentArrival() *ShipmentArrival {
	if e == nil {
		return nil
	}
	return e.ShipmentArrival
}

func (e *EntityDetails) GetShipmentDeparture() *ShipmentDeparture {
	if e == nil {
		return nil
	}
	return e.ShipmentDeparture
}

func (e *EntityDetails) GetCompanyType() *CompanyType {
	if e == nil {
		return nil
	}
	return e.CompanyType
}

func (e *EntityDetails) GetLatestStatus() *Status {
	if e == nil {
		return nil
	}
	return e.LatestStatus
}

func (e *EntityDetails) GetRisk() EntityRisk {
	if e == nil {
		return nil
	}
	return e.Risk
}

func (e *EntityDetails) GetAttributes() *AttributeDetails {
	if e == nil {
		return nil
	}
	return e.Attributes
}

func (e *EntityDetails) GetRelationships() *EntityRelationships {
	if e == nil {
		return nil
	}
	return e.Relationships
}

func (e *EntityDetails) GetPossiblySameAs() *PossiblySameAs {
	if e == nil {
		return nil
	}
	return e.PossiblySameAs
}

func (e *EntityDetails) GetReferencedBy() *ReferencedBy {
	if e == nil {
		return nil
	}
	return e.ReferencedBy
}

func (e *EntityDetails) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityDetails) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Harmonized Tariff Schedule Code associated with the entity/shipment
type EntityHsCode = string

// An explanation of why this entity was returned as the result of a query.
type EntityMatches = map[string][]string

// Type (registered/incorporated/active) and date of the earliest significant activity associated with the entity. Will appear as 'Registered YYYY-MM-DD'
type EntityRegistrationDate = string

// All relationships the entity is a part of.
type EntityRelationships struct {
	Limit int                 `json:"limit" url:"limit"`
	Size  *QualifiedCount     `json:"size,omitempty" url:"size,omitempty"`
	Next  interface{}         `json:"next,omitempty" url:"next,omitempty"`
	Data  []*RelationshipData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityRelationships) GetLimit() int {
	if e == nil {
		return 0
	}
	return e.Limit
}

func (e *EntityRelationships) GetSize() *QualifiedCount {
	if e == nil {
		return nil
	}
	return e.Size
}

func (e *EntityRelationships) GetNext() interface{} {
	if e == nil {
		return nil
	}
	return e.Next
}

func (e *EntityRelationships) GetData() []*RelationshipData {
	if e == nil {
		return nil
	}
	return e.Data
}

func (e *EntityRelationships) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityRelationships) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityRelationships
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityRelationships(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityRelationships) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Risk factors associated with the entity.
type EntityRisk = map[Risk]*RiskData

type EntitySummary struct {
	Attributes map[Attributes][]interface{} `json:"attributes,omitempty" url:"attributes,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntitySummary) GetAttributes() map[Attributes][]interface{} {
	if e == nil {
		return nil
	}
	return e.Attributes
}

func (e *EntitySummary) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntitySummary) UnmarshalJSON(data []byte) error {
	type unmarshaler EntitySummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntitySummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntitySummary) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Label in English if available. Translation performed by Sayari.
type EntityTranslatedLabel = string

// Identifiers associated with the entity.
type Identifier struct {
	Value string `json:"value" url:"value"`
	// [Identifier Type](/sayari-library/ontology/enumerated-types#identifier-type) or [Weak Identifier Type](/sayari-library/ontology/enumerated-types#weak-identifier-type)
	Type  *BothIdentifierTypes `json:"type,omitempty" url:"type,omitempty"`
	Label string               `json:"label" url:"label"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *Identifier) GetValue() string {
	if i == nil {
		return ""
	}
	return i.Value
}

func (i *Identifier) GetType() *BothIdentifierTypes {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *Identifier) GetLabel() string {
	if i == nil {
		return ""
	}
	return i.Label
}

func (i *Identifier) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Identifier) UnmarshalJSON(data []byte) error {
	type unmarshaler Identifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Identifier(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *Identifier) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Psa struct {
	PsaId     string          `json:"psa_id" url:"psa_id"`
	Label     string          `json:"label" url:"label"`
	Count     *int            `json:"count,omitempty" url:"count,omitempty"`
	MatchKeys []*PsaMatchKeys `json:"match_keys,omitempty" url:"match_keys,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Psa) GetPsaId() string {
	if p == nil {
		return ""
	}
	return p.PsaId
}

func (p *Psa) GetLabel() string {
	if p == nil {
		return ""
	}
	return p.Label
}

func (p *Psa) GetCount() *int {
	if p == nil {
		return nil
	}
	return p.Count
}

func (p *Psa) GetMatchKeys() []*PsaMatchKeys {
	if p == nil {
		return nil
	}
	return p.MatchKeys
}

func (p *Psa) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Psa) UnmarshalJSON(data []byte) error {
	type unmarshaler Psa
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Psa(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Psa) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The entity that is possibly the same as the target entity.
type PsaEntity struct {
	// Unique identifier of the entity
	Id string `json:"id" url:"id"`
	// Display name of the entity
	Label string `json:"label" url:"label"`
	// Number of outgoing relationships
	Degree int `json:"degree" url:"degree"`
	// True if the entity existed in the past but not at the present time, otherwise false. Always false for data curation.
	Closed bool `json:"closed" url:"closed"`
	// Convenience URL to the entity in the API.
	EntityUrl string `json:"entity_url" url:"entity_url"`
	// True if the entity has the ["Politically Exposed Person (PEP)" risk factor](/sayari-library/ontology/risk-factors#politically-exposed-person-pep-), otherwise false.
	Pep   bool    `json:"pep" url:"pep"`
	PsaId *string `json:"psa_id,omitempty" url:"psa_id,omitempty"`
	// Number of entities that are Possibly the Same As (PSA) the entity.
	PsaCount int `json:"psa_count" url:"psa_count"`
	// True if the entity has the ["Sanctioned" risk factor](/sayari-library/ontology/risk-factors#sanctioned), otherwise false.
	Sanctioned bool `json:"sanctioned" url:"sanctioned"`
	// The [entity type](/sayari-library/ontology/entities).
	Type        Entities      `json:"type" url:"type"`
	Identifiers []*Identifier `json:"identifiers,omitempty" url:"identifiers,omitempty"`
	// Entity [country](/sayari-library/ontology/enumerated-types#country)
	Countries []Country `json:"countries,omitempty" url:"countries,omitempty"`
	// Number of records associated with the entity, grouped by source.
	SourceCount map[string]*SourceCountInfo `json:"source_count,omitempty" url:"source_count,omitempty"`
	// List of physical addresses associated with the entity. See more [here](/sayari-library/ontology/attributes#address)
	Addresses  []string       `json:"addresses,omitempty" url:"addresses,omitempty"`
	TradeCount map[string]int `json:"trade_count,omitempty" url:"trade_count,omitempty"`
	// Birth date of a person. See more [here](/sayari-library/ontology/attributes#date-of-birth)
	DateOfBirth           *string           `json:"date_of_birth,omitempty" url:"date_of_birth,omitempty"`
	RelationshipCount     RelationshipCount `json:"relationship_count,omitempty" url:"relationship_count,omitempty"`
	UserRelationshipCount RelationshipCount `json:"user_relationship_count,omitempty" url:"user_relationship_count,omitempty"`
	// Count of attributes for a given [attribute type](/sayari-library/ontology/attributes)
	AttributeCount map[Attributes]int `json:"attribute_count,omitempty" url:"attribute_count,omitempty"`
	// Count of user-created attributes for a given [attribute type](/sayari-library/ontology/attributes)
	UserAttributeCount map[Attributes]int `json:"user_attribute_count,omitempty" url:"user_attribute_count,omitempty"`
	// Count of attributes for a given [attribute type](/sayari-library/ontology/attributes)
	AttributeCounts map[Attributes]int `json:"attribute_counts,omitempty" url:"attribute_counts,omitempty"`
	// Count of user-created attributes for a given [attribute type](/sayari-library/ontology/attributes)
	UserAttributeCounts      map[Attributes]int      `json:"user_attribute_counts,omitempty" url:"user_attribute_counts,omitempty"`
	RelatedEntitiesCount     int                     `json:"related_entities_count" url:"related_entities_count"`
	UserRelatedEntitiesCount int                     `json:"user_related_entities_count" url:"user_related_entities_count"`
	UserRecordCount          int                     `json:"user_record_count" url:"user_record_count"`
	ReferenceId              *string                 `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	Risk                     EntityRisk              `json:"risk,omitempty" url:"risk,omitempty"`
	RegistrationDate         *EntityRegistrationDate `json:"registration_date,omitempty" url:"registration_date,omitempty"`
	CompanyType              *CompanyType            `json:"company_type,omitempty" url:"company_type,omitempty"`
	LatestStatus             *Status                 `json:"latest_status,omitempty" url:"latest_status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PsaEntity) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PsaEntity) GetLabel() string {
	if p == nil {
		return ""
	}
	return p.Label
}

func (p *PsaEntity) GetDegree() int {
	if p == nil {
		return 0
	}
	return p.Degree
}

func (p *PsaEntity) GetClosed() bool {
	if p == nil {
		return false
	}
	return p.Closed
}

func (p *PsaEntity) GetEntityUrl() string {
	if p == nil {
		return ""
	}
	return p.EntityUrl
}

func (p *PsaEntity) GetPep() bool {
	if p == nil {
		return false
	}
	return p.Pep
}

func (p *PsaEntity) GetPsaId() *string {
	if p == nil {
		return nil
	}
	return p.PsaId
}

func (p *PsaEntity) GetPsaCount() int {
	if p == nil {
		return 0
	}
	return p.PsaCount
}

func (p *PsaEntity) GetSanctioned() bool {
	if p == nil {
		return false
	}
	return p.Sanctioned
}

func (p *PsaEntity) GetType() Entities {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PsaEntity) GetIdentifiers() []*Identifier {
	if p == nil {
		return nil
	}
	return p.Identifiers
}

func (p *PsaEntity) GetCountries() []Country {
	if p == nil {
		return nil
	}
	return p.Countries
}

func (p *PsaEntity) GetSourceCount() map[string]*SourceCountInfo {
	if p == nil {
		return nil
	}
	return p.SourceCount
}

func (p *PsaEntity) GetAddresses() []string {
	if p == nil {
		return nil
	}
	return p.Addresses
}

func (p *PsaEntity) GetTradeCount() map[string]int {
	if p == nil {
		return nil
	}
	return p.TradeCount
}

func (p *PsaEntity) GetDateOfBirth() *string {
	if p == nil {
		return nil
	}
	return p.DateOfBirth
}

func (p *PsaEntity) GetRelationshipCount() RelationshipCount {
	if p == nil {
		return nil
	}
	return p.RelationshipCount
}

func (p *PsaEntity) GetUserRelationshipCount() RelationshipCount {
	if p == nil {
		return nil
	}
	return p.UserRelationshipCount
}

func (p *PsaEntity) GetAttributeCount() map[Attributes]int {
	if p == nil {
		return nil
	}
	return p.AttributeCount
}

func (p *PsaEntity) GetUserAttributeCount() map[Attributes]int {
	if p == nil {
		return nil
	}
	return p.UserAttributeCount
}

func (p *PsaEntity) GetAttributeCounts() map[Attributes]int {
	if p == nil {
		return nil
	}
	return p.AttributeCounts
}

func (p *PsaEntity) GetUserAttributeCounts() map[Attributes]int {
	if p == nil {
		return nil
	}
	return p.UserAttributeCounts
}

func (p *PsaEntity) GetRelatedEntitiesCount() int {
	if p == nil {
		return 0
	}
	return p.RelatedEntitiesCount
}

func (p *PsaEntity) GetUserRelatedEntitiesCount() int {
	if p == nil {
		return 0
	}
	return p.UserRelatedEntitiesCount
}

func (p *PsaEntity) GetUserRecordCount() int {
	if p == nil {
		return 0
	}
	return p.UserRecordCount
}

func (p *PsaEntity) GetReferenceId() *string {
	if p == nil {
		return nil
	}
	return p.ReferenceId
}

func (p *PsaEntity) GetRisk() EntityRisk {
	if p == nil {
		return nil
	}
	return p.Risk
}

func (p *PsaEntity) GetRegistrationDate() *EntityRegistrationDate {
	if p == nil {
		return nil
	}
	return p.RegistrationDate
}

func (p *PsaEntity) GetCompanyType() *CompanyType {
	if p == nil {
		return nil
	}
	return p.CompanyType
}

func (p *PsaEntity) GetLatestStatus() *Status {
	if p == nil {
		return nil
	}
	return p.LatestStatus
}

func (p *PsaEntity) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PsaEntity) UnmarshalJSON(data []byte) error {
	type unmarshaler PsaEntity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PsaEntity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PsaEntity) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PsaMatchKeys struct {
	Key        string `json:"key" url:"key"`
	Normalized string `json:"normalized" url:"normalized"`
	Original   string `json:"original" url:"original"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PsaMatchKeys) GetKey() string {
	if p == nil {
		return ""
	}
	return p.Key
}

func (p *PsaMatchKeys) GetNormalized() string {
	if p == nil {
		return ""
	}
	return p.Normalized
}

func (p *PsaMatchKeys) GetOriginal() string {
	if p == nil {
		return ""
	}
	return p.Original
}

func (p *PsaMatchKeys) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PsaMatchKeys) UnmarshalJSON(data []byte) error {
	type unmarshaler PsaMatchKeys
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PsaMatchKeys(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PsaMatchKeys) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// List of entities that are Possibly the Same As (PSA) the entity.
type PossiblySameAs struct {
	Limit  int                   `json:"limit" url:"limit"`
	Size   *QualifiedCount       `json:"size,omitempty" url:"size,omitempty"`
	Offset *int                  `json:"offset,omitempty" url:"offset,omitempty"`
	Next   interface{}           `json:"next,omitempty" url:"next,omitempty"`
	Data   []*PossiblySameAsData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PossiblySameAs) GetLimit() int {
	if p == nil {
		return 0
	}
	return p.Limit
}

func (p *PossiblySameAs) GetSize() *QualifiedCount {
	if p == nil {
		return nil
	}
	return p.Size
}

func (p *PossiblySameAs) GetOffset() *int {
	if p == nil {
		return nil
	}
	return p.Offset
}

func (p *PossiblySameAs) GetNext() interface{} {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PossiblySameAs) GetData() []*PossiblySameAsData {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PossiblySameAs) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PossiblySameAs) UnmarshalJSON(data []byte) error {
	type unmarshaler PossiblySameAs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PossiblySameAs(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PossiblySameAs) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PossiblySameAsData struct {
	Editable *bool                             `json:"editable,omitempty" url:"editable,omitempty"`
	Entity   *PsaEntity                        `json:"entity,omitempty" url:"entity,omitempty"`
	Matches  map[string][]*PossiblySameAsMatch `json:"matches,omitempty" url:"matches,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PossiblySameAsData) GetEditable() *bool {
	if p == nil {
		return nil
	}
	return p.Editable
}

func (p *PossiblySameAsData) GetEntity() *PsaEntity {
	if p == nil {
		return nil
	}
	return p.Entity
}

func (p *PossiblySameAsData) GetMatches() map[string][]*PossiblySameAsMatch {
	if p == nil {
		return nil
	}
	return p.Matches
}

func (p *PossiblySameAsData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PossiblySameAsData) UnmarshalJSON(data []byte) error {
	type unmarshaler PossiblySameAsData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PossiblySameAsData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PossiblySameAsData) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PossiblySameAsMatch struct {
	Source string `json:"source" url:"source"`
	Target string `json:"target" url:"target"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PossiblySameAsMatch) GetSource() string {
	if p == nil {
		return ""
	}
	return p.Source
}

func (p *PossiblySameAsMatch) GetTarget() string {
	if p == nil {
		return ""
	}
	return p.Target
}

func (p *PossiblySameAsMatch) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PossiblySameAsMatch) UnmarshalJSON(data []byte) error {
	type unmarshaler PossiblySameAsMatch
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PossiblySameAsMatch(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PossiblySameAsMatch) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RecordDetails struct {
	// The unique identifier for a record in the database
	Id    string `json:"id" url:"id"`
	Label string `json:"label" url:"label"`
	// The unique identifier for a source in the database
	Source string `json:"source" url:"source"`
	// The date the record was published
	PublicationDate *string `json:"publication_date,omitempty" url:"publication_date,omitempty"`
	// The date Sayari acquired this record
	AcquisitionDate string `json:"acquisition_date" url:"acquisition_date"`
	// Number of times this record is referenced
	ReferencesCount int `json:"references_count" url:"references_count"`
	// The url to download the record from Sayari
	RecordUrl string `json:"record_url" url:"record_url"`
	// The url to access to original source
	SourceUrl    *string             `json:"source_url,omitempty" url:"source_url,omitempty"`
	DocumentUrls []string            `json:"document_urls,omitempty" url:"document_urls,omitempty"`
	Matches      map[string][]string `json:"matches,omitempty" url:"matches,omitempty"`
	Country      *Country            `json:"country,omitempty" url:"country,omitempty"`
	Page         *float64            `json:"page,omitempty" url:"page,omitempty"`
	PageCount    *float64            `json:"page_count,omitempty" url:"page_count,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RecordDetails) GetId() string {
	if r == nil {
		return ""
	}
	return r.Id
}

func (r *RecordDetails) GetLabel() string {
	if r == nil {
		return ""
	}
	return r.Label
}

func (r *RecordDetails) GetSource() string {
	if r == nil {
		return ""
	}
	return r.Source
}

func (r *RecordDetails) GetPublicationDate() *string {
	if r == nil {
		return nil
	}
	return r.PublicationDate
}

func (r *RecordDetails) GetAcquisitionDate() string {
	if r == nil {
		return ""
	}
	return r.AcquisitionDate
}

func (r *RecordDetails) GetReferencesCount() int {
	if r == nil {
		return 0
	}
	return r.ReferencesCount
}

func (r *RecordDetails) GetRecordUrl() string {
	if r == nil {
		return ""
	}
	return r.RecordUrl
}

func (r *RecordDetails) GetSourceUrl() *string {
	if r == nil {
		return nil
	}
	return r.SourceUrl
}

func (r *RecordDetails) GetDocumentUrls() []string {
	if r == nil {
		return nil
	}
	return r.DocumentUrls
}

func (r *RecordDetails) GetMatches() map[string][]string {
	if r == nil {
		return nil
	}
	return r.Matches
}

func (r *RecordDetails) GetCountry() *Country {
	if r == nil {
		return nil
	}
	return r.Country
}

func (r *RecordDetails) GetPage() *float64 {
	if r == nil {
		return nil
	}
	return r.Page
}

func (r *RecordDetails) GetPageCount() *float64 {
	if r == nil {
		return nil
	}
	return r.PageCount
}

func (r *RecordDetails) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordDetails) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// List of records that reference the entity.
type ReferencedBy struct {
	Limit  int                 `json:"limit" url:"limit"`
	Size   *QualifiedCount     `json:"size,omitempty" url:"size,omitempty"`
	Offset *int                `json:"offset,omitempty" url:"offset,omitempty"`
	Next   interface{}         `json:"next,omitempty" url:"next,omitempty"`
	Data   []*ReferencedByData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ReferencedBy) GetLimit() int {
	if r == nil {
		return 0
	}
	return r.Limit
}

func (r *ReferencedBy) GetSize() *QualifiedCount {
	if r == nil {
		return nil
	}
	return r.Size
}

func (r *ReferencedBy) GetOffset() *int {
	if r == nil {
		return nil
	}
	return r.Offset
}

func (r *ReferencedBy) GetNext() interface{} {
	if r == nil {
		return nil
	}
	return r.Next
}

func (r *ReferencedBy) GetData() []*ReferencedByData {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ReferencedBy) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferencedBy) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferencedBy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferencedBy(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferencedBy) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferencedByData struct {
	Record *RecordDetails       `json:"record,omitempty" url:"record,omitempty"`
	Type   ReferencedByDataType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ReferencedByData) GetRecord() *RecordDetails {
	if r == nil {
		return nil
	}
	return r.Record
}

func (r *ReferencedByData) GetType() ReferencedByDataType {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *ReferencedByData) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferencedByData) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferencedByData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferencedByData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferencedByData) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferencedByDataType string

const (
	ReferencedByDataTypeAbout    ReferencedByDataType = "about"
	ReferencedByDataTypeMentions ReferencedByDataType = "mentions"
)

func NewReferencedByDataTypeFromString(s string) (ReferencedByDataType, error) {
	switch s {
	case "about":
		return ReferencedByDataTypeAbout, nil
	case "mentions":
		return ReferencedByDataTypeMentions, nil
	}
	var t ReferencedByDataType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ReferencedByDataType) Ptr() *ReferencedByDataType {
	return &r
}

// Count of related entities for a given [relationship type](/sayari-library/ontology/relationships).
type RelationshipCount = map[Relationships]int

type RelationshipData struct {
	Target *EntityDetails `json:"target,omitempty" url:"target,omitempty"`
	// Additional information for each [relationship type](/sayari-library/ontology/relationships).
	Types         map[Relationships][]*RelationshipInfo `json:"types,omitempty" url:"types,omitempty"`
	Dates         []string                              `json:"dates,omitempty" url:"dates,omitempty"`
	FirstObserved *string                               `json:"first_observed,omitempty" url:"first_observed,omitempty"`
	Former        *bool                                 `json:"former,omitempty" url:"former,omitempty"`
	LastObserved  *string                               `json:"last_observed,omitempty" url:"last_observed,omitempty"`
	StartDate     *string                               `json:"start_date,omitempty" url:"start_date,omitempty"`
	EndDate       *string                               `json:"end_date,omitempty" url:"end_date,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RelationshipData) GetTarget() *EntityDetails {
	if r == nil {
		return nil
	}
	return r.Target
}

func (r *RelationshipData) GetTypes() map[Relationships][]*RelationshipInfo {
	if r == nil {
		return nil
	}
	return r.Types
}

func (r *RelationshipData) GetDates() []string {
	if r == nil {
		return nil
	}
	return r.Dates
}

func (r *RelationshipData) GetFirstObserved() *string {
	if r == nil {
		return nil
	}
	return r.FirstObserved
}

func (r *RelationshipData) GetFormer() *bool {
	if r == nil {
		return nil
	}
	return r.Former
}

func (r *RelationshipData) GetLastObserved() *string {
	if r == nil {
		return nil
	}
	return r.LastObserved
}

func (r *RelationshipData) GetStartDate() *string {
	if r == nil {
		return nil
	}
	return r.StartDate
}

func (r *RelationshipData) GetEndDate() *string {
	if r == nil {
		return nil
	}
	return r.EndDate
}

func (r *RelationshipData) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RelationshipData) UnmarshalJSON(data []byte) error {
	type unmarshaler RelationshipData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RelationshipData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RelationshipData) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RelationshipInfo struct {
	Editable        *bool                        `json:"editable,omitempty" url:"editable,omitempty"`
	Record          string                       `json:"record" url:"record"`
	Attributes      map[Attributes][]interface{} `json:"attributes,omitempty" url:"attributes,omitempty"`
	Date            *string                      `json:"date,omitempty" url:"date,omitempty"`
	FromDate        *string                      `json:"from_date,omitempty" url:"from_date,omitempty"`
	ToDate          *string                      `json:"to_date,omitempty" url:"to_date,omitempty"`
	AcquisitionDate string                       `json:"acquisition_date" url:"acquisition_date"`
	Former          *bool                        `json:"former,omitempty" url:"former,omitempty"`
	PublicationDate *string                      `json:"publication_date,omitempty" url:"publication_date,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RelationshipInfo) GetEditable() *bool {
	if r == nil {
		return nil
	}
	return r.Editable
}

func (r *RelationshipInfo) GetRecord() string {
	if r == nil {
		return ""
	}
	return r.Record
}

func (r *RelationshipInfo) GetAttributes() map[Attributes][]interface{} {
	if r == nil {
		return nil
	}
	return r.Attributes
}

func (r *RelationshipInfo) GetDate() *string {
	if r == nil {
		return nil
	}
	return r.Date
}

func (r *RelationshipInfo) GetFromDate() *string {
	if r == nil {
		return nil
	}
	return r.FromDate
}

func (r *RelationshipInfo) GetToDate() *string {
	if r == nil {
		return nil
	}
	return r.ToDate
}

func (r *RelationshipInfo) GetAcquisitionDate() string {
	if r == nil {
		return ""
	}
	return r.AcquisitionDate
}

func (r *RelationshipInfo) GetFormer() *bool {
	if r == nil {
		return nil
	}
	return r.Former
}

func (r *RelationshipInfo) GetPublicationDate() *string {
	if r == nil {
		return nil
	}
	return r.PublicationDate
}

func (r *RelationshipInfo) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RelationshipInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler RelationshipInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RelationshipInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RelationshipInfo) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RiskData struct {
	Value    *RiskValue             `json:"value,omitempty" url:"value,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The severity of the risk.
	Level RiskLevel `json:"level" url:"level"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RiskData) GetValue() *RiskValue {
	if r == nil {
		return nil
	}
	return r.Value
}

func (r *RiskData) GetMetadata() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.Metadata
}

func (r *RiskData) GetLevel() RiskLevel {
	if r == nil {
		return ""
	}
	return r.Level
}

func (r *RiskData) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RiskData) UnmarshalJSON(data []byte) error {
	type unmarshaler RiskData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RiskData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RiskData) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RiskLevel string

const (
	RiskLevelCritical RiskLevel = "critical"
	RiskLevelHigh     RiskLevel = "high"
	RiskLevelElevated RiskLevel = "elevated"
	RiskLevelRelevant RiskLevel = "relevant"
)

func NewRiskLevelFromString(s string) (RiskLevel, error) {
	switch s {
	case "critical":
		return RiskLevelCritical, nil
	case "high":
		return RiskLevelHigh, nil
	case "elevated":
		return RiskLevelElevated, nil
	case "relevant":
		return RiskLevelRelevant, nil
	}
	var t RiskLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RiskLevel) Ptr() *RiskLevel {
	return &r
}

type RiskValue struct {
	String  string
	Double  float64
	Boolean bool

	typ string
}

func NewRiskValueFromString(value string) *RiskValue {
	return &RiskValue{typ: "String", String: value}
}

func NewRiskValueFromDouble(value float64) *RiskValue {
	return &RiskValue{typ: "Double", Double: value}
}

func NewRiskValueFromBoolean(value bool) *RiskValue {
	return &RiskValue{typ: "Boolean", Boolean: value}
}

func (r *RiskValue) GetString() string {
	if r == nil {
		return ""
	}
	return r.String
}

func (r *RiskValue) GetDouble() float64 {
	if r == nil {
		return 0
	}
	return r.Double
}

func (r *RiskValue) GetBoolean() bool {
	if r == nil {
		return false
	}
	return r.Boolean
}

func (r *RiskValue) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typ = "String"
		r.String = valueString
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		r.typ = "Double"
		r.Double = valueDouble
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		r.typ = "Boolean"
		r.Boolean = valueBoolean
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RiskValue) MarshalJSON() ([]byte, error) {
	if r.typ == "String" || r.String != "" {
		return json.Marshal(r.String)
	}
	if r.typ == "Double" || r.Double != 0 {
		return json.Marshal(r.Double)
	}
	if r.typ == "Boolean" || r.Boolean != false {
		return json.Marshal(r.Boolean)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RiskValueVisitor interface {
	VisitString(string) error
	VisitDouble(float64) error
	VisitBoolean(bool) error
}

func (r *RiskValue) Accept(visitor RiskValueVisitor) error {
	if r.typ == "String" || r.String != "" {
		return visitor.VisitString(r.String)
	}
	if r.typ == "Double" || r.Double != 0 {
		return visitor.VisitDouble(r.Double)
	}
	if r.typ == "Boolean" || r.Boolean != false {
		return visitor.VisitBoolean(r.Boolean)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

type SearchField string

const (
	SearchFieldName            SearchField = "name"
	SearchFieldIdentifier      SearchField = "identifier"
	SearchFieldAddress         SearchField = "address"
	SearchFieldBusinessPurpose SearchField = "business_purpose"
	SearchFieldDateOfBirth     SearchField = "date_of_birth"
	SearchFieldContact         SearchField = "contact"
)

func NewSearchFieldFromString(s string) (SearchField, error) {
	switch s {
	case "name":
		return SearchFieldName, nil
	case "identifier":
		return SearchFieldIdentifier, nil
	case "address":
		return SearchFieldAddress, nil
	case "business_purpose":
		return SearchFieldBusinessPurpose, nil
	case "date_of_birth":
		return SearchFieldDateOfBirth, nil
	case "contact":
		return SearchFieldContact, nil
	}
	var t SearchField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchField) Ptr() *SearchField {
	return &s
}

// Arrival date of a shipment.
type ShipmentArrival = string

// Departure date of a shipment.
type ShipmentDeparture = string

// The number of time the entity is referenced by a source.
type SourceCountInfo struct {
	Count int    `json:"count" url:"count"`
	Label string `json:"label" url:"label"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SourceCountInfo) GetCount() int {
	if s == nil {
		return 0
	}
	return s.Count
}

func (s *SourceCountInfo) GetLabel() string {
	if s == nil {
		return ""
	}
	return s.Label
}

func (s *SourceCountInfo) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SourceCountInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceCountInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceCountInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceCountInfo) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The most recent status of an entity and when that status was observed.
type Status struct {
	Status string  `json:"status" url:"status"`
	Date   *string `json:"date,omitempty" url:"date,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Status) GetStatus() string {
	if s == nil {
		return ""
	}
	return s.Status
}

func (s *Status) GetDate() *string {
	if s == nil {
		return nil
	}
	return s.Date
}

func (s *Status) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Status) UnmarshalJSON(data []byte) error {
	type unmarshaler Status
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Status(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Status) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}
